//  SnoopyScreenSaverView.swift

import AVFoundation
import AVKit
import ScreenSaver
import SpriteKit

// Define ViewStateType enum
enum ViewStateType {
    case initial
    case playingAS
    case transitioningToHalftoneHide  // Playing TM_Hide
    case playingSTHide
    case playingRPH
    case playingBP  // Includes Loop
    case playingAPIntro
    case playingAPLoop
    case playingAPOutro
    case playingCM
    case decidingNextHalftoneAction  // After BP loop or AP/CM finishes
    case transitioningToASReveal  // Playing ST_Reveal
    case playingTMReveal
    case playingSSIntro  // Similar states for SS Loop, Outro etc.
    // ... add other states as needed
}

@objc(SnoopyScreenSaverView)
class SnoopyScreenSaverView: ScreenSaverView {
    // å¸¸é‡
    private let scale: CGFloat = 720.0 / 1080.0
    private let offside: CGFloat = 180.0 / 1080.0
    
    // --- State Management Properties ---
    private var allClips: [SnoopyClip] = []
    private var currentClipsQueue: [SnoopyClip] = []
    private var currentClipIndex: Int = 0
    private var currentNode: String?  // e.g., "BP001"
    private var currentStateType: ViewStateType = .initial
    private var currentRepeatCount: Int = 0  // For handling loops manually
    private var isMasking: Bool = false  // Flag to indicate mask transition is active
    // --- æ·»åŠ çŠ¶æ€å˜é‡ ---
    private var bpCycleCount: Int = 0
    private var lastTransitionNumber: String?  // Stores the number (e.g., "001") of the last ST/TM Reveal
    private var nextAfterAS: [SnoopyClip] = []  // Stores clips to play after AS finishes
    private var isFirstASPlayback: Bool = true  // æ ‡è®°æ˜¯å¦ä¸ºåˆæ¬¡ASæ’­æ”¾
    // --- ç»“æŸæ·»åŠ  ---
    
    // --- Player and Nodes ---
    private var queuePlayer: AVQueuePlayer?
    private var playerItem: AVPlayerItem?  // Keep track of the current item for notifications
    private var overlayPlayer: AVQueuePlayer?  // Player for VI/WE overlays
    private var overlayPlayerItem: AVPlayerItem?  // Track overlay item
    private var overlayRepeatCount: Int = 0  // For overlay loops
    
    // --- AS/SS Independent Player System ---
    private var asPlayer: AVPlayer?  // Independent player for AS/SS content
    private var asPlayerItem: AVPlayerItem?  // Track AS/SS player item
    private var asVideoNode: SKVideoNode?  // Video node for AS/SS content in cropNode
    
    // --- Masking Properties ---
    private var cropNode: SKCropNode?
    
    // --- HEIC Sequence Player Properties ---
    private var heicSequencePlayer: HEICSequencePlayer?
    private var tmMaskSpriteNode: SKSpriteNode?
    
    private var skView: SKView?
    private var scene: SKScene?
    private var backgroundColorNode: SKSpriteNode?
    private var halftoneNode: SKSpriteNode?
    private var backgroundImageNode: SKSpriteNode?  // IS image
    private var videoNode: SKVideoNode?
    private var overlayNode: SKVideoNode?  // Node for VI/WE overlays
    
    private let colors: [NSColor] = [
        NSColor(red: 50.0 / 255.0, green: 60.0 / 255.0, blue: 47.0 / 255.0, alpha: 1.0),
        NSColor(red: 5.0 / 255.0, green: 168.0 / 255.0, blue: 157.0 / 255.0, alpha: 1.0),
        NSColor(red: 65.0 / 255.0, green: 176.0 / 255.0, blue: 246.0 / 255.0, alpha: 1.0),
        NSColor(red: 238.0 / 255.0, green: 95.0 / 255.0, blue: 167.0 / 255.0, alpha: 1.0),
        NSColor.black,
    ]
    
    private var backgroundImages: [String] = []
    
    // MARK: - Initialization and Setup
    
    override init?(frame: NSRect, isPreview: Bool) {
        super.init(frame: frame, isPreview: isPreview)
        
        animationTimeInterval = 1.0 / 30.0
        
        // åœ¨Sonomaä¸Šå»¶è¿Ÿåˆå§‹åŒ–ï¼Œé¿å…legacyScreenSaveré—®é¢˜
        if #available(macOS 14.0, *) {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.setupView()
            }
        } else {
            setupView()
        }
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        
        animationTimeInterval = 1.0 / 30.0
        
        // åœ¨Sonomaä¸Šå»¶è¿Ÿåˆå§‹åŒ–ï¼Œé¿å…legacyScreenSaveré—®é¢˜
        if #available(macOS 14.0, *) {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                self.setupView()
            }
        } else {
            setupView()
        }
    }
    
    private func setupView() {
        loadBackgroundImages()  // Load IS names
        
        // Setup SKView and Scene first
        setupScene()
        
        // Asynchronously load clips and then start
        Task {
            do {
                print("Loading clips...")
                // Use SnoopyClip.loadClips() to load clips
                self.allClips = try await SnoopyClip.loadClips()
                print("Clips loaded: \(self.allClips.count)")
                guard !self.allClips.isEmpty else {
                    print("No clips loaded, cannot start.")
                    // Handle error state - maybe show a static image or message
                    return
                }
                // Setup player *after* clips are loaded
                setupPlayer()
                // Set initial state and start playback
                setupInitialStateAndPlay()
            } catch {
                print("Error loading clips: \(error)")
                // Handle error state
            }
        }
        
        // Notifications remain the same
        setNotifications()
    }
    
    private func loadBackgroundImages() {
        guard let resourcePath = Bundle(for: type(of: self)).resourcePath else { return }
        let fileManager = FileManager.default
        
        do {
            let files = try fileManager.contentsOfDirectory(atPath: resourcePath)
            // Filter for IS background images only, excluding TM animation files
            let heicFiles = files.filter { file in
                file.hasSuffix(".heic") && file.contains("_IS")
            }
            self.backgroundImages = heicFiles
            print("ğŸ–¼ï¸ Loaded \(heicFiles.count) IS background images")
        } catch {
            print("Error reading Resources directory: \(error.localizedDescription)")
        }
    }
    
    private func setupScene() {
        guard skView == nil else { return }  // Prevent double setup
        
        // --- Initialize Players FIRST ---
        self.queuePlayer = AVQueuePlayer()
        self.overlayPlayer = AVQueuePlayer()
        self.asPlayer = AVPlayer()  // Independent AS/SS player
        
        let skView = SKView(frame: bounds)
        skView.wantsLayer = true
        skView.layer?.backgroundColor = NSColor.clear.cgColor  // Make SKView transparent
        skView.ignoresSiblingOrder = true
        skView.allowsTransparency = true
        self.skView = skView
        addSubview(skView)
        
        let scene = SKScene(size: bounds.size)
        scene.scaleMode = .aspectFill
        scene.backgroundColor = .clear  // Scene background clear
        self.scene = scene
        
        // Layer 0: Solid Background Color
        let solidColorBGNode = SKSpriteNode(color: NSColor.black, size: scene.size)
        solidColorBGNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        solidColorBGNode.zPosition = 0
        solidColorBGNode.name = "backgroundColor"
        solidColorBGNode.alpha = 1
        scene.addChild(solidColorBGNode)
        self.backgroundColorNode = solidColorBGNode
        
        // Layer 1: Halftone Pattern
        if let bgImagePath = Bundle(for: type(of: self)).path(
            forResource: "halftone_pattern", ofType: "png"),
           let bgImage = NSImage(contentsOfFile: bgImagePath)
        {
            let bgtexture = SKTexture(image: bgImage)
            let halftone = SKSpriteNode(texture: bgtexture)
            halftone.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
            halftone.size = scene.size
            halftone.zPosition = 1
            halftone.alpha = 0  // åˆå§‹è®¾ç½®ä¸ºé€æ˜ï¼Œç›´åˆ°ASå¼€å§‹æ’­æ”¾
            halftone.name = "halftonePattern"
            halftone.blendMode = .alpha
            scene.addChild(halftone)
            self.halftoneNode = halftone
        }
        
        // Layer 2: IS Background Image
        let imageNode = SKSpriteNode()
        imageNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        imageNode.zPosition = 2
        imageNode.name = "backgroundImage"
        imageNode.blendMode = .alpha
        imageNode.alpha = 0  // åˆå§‹è®¾ç½®ä¸ºé€æ˜ï¼Œç›´åˆ°ASå¼€å§‹æ’­æ”¾
        scene.addChild(imageNode)
        self.backgroundImageNode = imageNode
        
        // Layer 3: Main Video Node - Initialize WITH player (ç”¨äºæ’­æ”¾BPã€APã€CMã€STã€RPH)
        guard let mainPlayer = self.queuePlayer else {
            print("Error: Main queuePlayer is nil during scene setup.")
            return
        }
        let videoNode = SKVideoNode(avPlayer: mainPlayer)
        videoNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        videoNode.size = scene.size
        videoNode.zPosition = 3  // å¸¸è§„å†…å®¹åœ¨Layer 3
        videoNode.name = "videoNode"
        scene.addChild(videoNode)
        self.videoNode = videoNode
        
        // Layer 4: Overlay Node (For VI/WE) - Initialize WITH player
        guard let ovPlayer = self.overlayPlayer else {
            print("Error: Overlay player is nil during scene setup.")
            return
        }
        let overlayNode = SKVideoNode(avPlayer: ovPlayer)
        overlayNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        overlayNode.size = scene.size  // Adjust size/position as needed for overlays
        overlayNode.zPosition = 4
        overlayNode.name = "overlayNode"
        overlayNode.isHidden = true  // Initially hidden
        scene.addChild(overlayNode)
        self.overlayNode = overlayNode
        
        // Layer 10: åˆ›å»ºcropNodeä¸“é—¨ç”¨äºAS/SSå†…å®¹ï¼Œå§‹ç»ˆä¿æŒåœ¨æœ€ä¸Šå±‚ä»¥ç¡®ä¿é®ç½©æ•ˆæœæ­£ç¡®
        let cropNode = SKCropNode()
        cropNode.position = CGPoint(x: scene.size.width / 2, y: scene.size.height / 2)
        cropNode.zPosition = 10  // AS/SSå†…å®¹åœ¨æœ€ä¸Šå±‚ï¼Œä¾¿äºé®ç½©å¤„ç†
        scene.addChild(cropNode)
        self.cropNode = cropNode
        
        // AS/SS Video Node - Initialize WITH independent AS player
        guard let asPlayer = self.asPlayer else {
            print("Error: AS player is nil during scene setup.")
            return
        }
        let asVideoNode = SKVideoNode(avPlayer: asPlayer)
        asVideoNode.position = CGPoint.zero  // Position relative to cropNode
        asVideoNode.size = scene.size
        asVideoNode.name = "asVideoNode"
        asVideoNode.isHidden = true  // Initially hidden until AS content plays
        cropNode.addChild(asVideoNode)
        self.asVideoNode = asVideoNode
        
        skView.presentScene(scene)
    }
    
    private func setupPlayer() {
        guard self.queuePlayer != nil, self.overlayPlayer != nil else {
            print("Error: Players not initialized before setupPlayer call.")
            return
        }
        
        NotificationCenter.default.removeObserver(
            self, name: .AVPlayerItemDidPlayToEndTime, object: nil)
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(playerItemDidReachEnd(_:)),
            name: .AVPlayerItemDidPlayToEndTime,
            object: nil
        )
    }
    
    private func setupInitialStateAndPlay() {
        print("Setting up initial state...")
        guard let initialAS = findRandomClip(ofType: .AS) else {
            print("Error: No AS clips found to start.")
            return
        }
        print("Initial AS: \(initialAS.fileName)")
        
        // ä¸ºåˆå§‹ASè®¾ç½®éšæœºè½¬åœºç¼–å·ï¼Œæ’é™¤006
        let availableTransitionNumbers = allClips.compactMap { clip in
            guard clip.type == .TM_Hide else { return nil }
            return clip.number
        }.filter { $0 != "006" } // æ’é™¤006ç¼–å·
        
        if let randomNumber = availableTransitionNumbers.randomElement() {
            self.lastTransitionNumber = randomNumber
            print("ğŸ² ä¸ºåˆå§‹ASè®¾ç½®éšæœºè½¬åœºç¼–å·: \(randomNumber)")
        } else {
            print("âš ï¸ è­¦å‘Šï¼šæ— æ³•æ‰¾åˆ°å¯ç”¨çš„è½¬åœºç¼–å·")
        }
        
        currentStateType = .playingAS
        currentClipsQueue = [initialAS]
        currentClipIndex = 0
        playNextClipInQueue()
    }
    
    // MARK: - Core Playback Logic
    
    private func playNextClipInQueue() {
        guard !isMasking else {
            print("â³ é®ç½©è¿‡æ¸¡æ­£åœ¨è¿›è¡Œä¸­ï¼Œå»¶è¿Ÿæ’­æ”¾ä¸‹ä¸€ä¸ªä¸»ç‰‡æ®µã€‚")
            return
        }
        guard currentClipIndex < currentClipsQueue.count else {
            print("âœ… å½“å‰é˜Ÿåˆ—æ’­æ”¾å®Œæ¯•ã€‚å¤„ç†åºåˆ—ç»“æŸ...")
            handleEndOfQueue()
            return
        }
        
        let clipToPlay = currentClipsQueue[currentClipIndex]
        print(
            "ğŸ¬ æ­£åœ¨å¤„ç†ç‰‡æ®µ (\(currentClipIndex + 1)/\(currentClipsQueue.count)): \(clipToPlay.fileName) (\(clipToPlay.type))"
        )
        
        // é¦–å…ˆæ›´æ–°å½“å‰çŠ¶æ€ï¼Œç¡®ä¿çŠ¶æ€æ­£ç¡®
        updateStateForStartingClip(clipToPlay)
        
        if clipToPlay.type == .TM_Hide || clipToPlay.type == .TM_Reveal {
            let basePattern = clipToPlay.fileName
            print("ğŸ” TMç‰‡æ®µè¯¦æƒ…: fileName=\(clipToPlay.fileName), type=\(clipToPlay.type), groupID=\(clipToPlay.groupID ?? "nil"), number=\(clipToPlay.number ?? "nil")")
            
            // ä½¿ç”¨HEICSequencePlayeræ¥æ’­æ”¾TMåºåˆ—
            if self.heicSequencePlayer == nil {
                self.heicSequencePlayer = HEICSequencePlayer()
            }
            
            guard let player = self.heicSequencePlayer else {
                print("âŒ é”™è¯¯ï¼šæ— æ³•åˆ›å»ºHEICåºåˆ—æ’­æ”¾å™¨ã€‚è·³è¿‡ç‰‡æ®µ [\(clipToPlay.fileName)]ã€‚")
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            // åŠ è½½TMåºåˆ—
            let success = player.loadSequence(basePattern: basePattern)
            if !success {
                print("âŒ é”™è¯¯ï¼šæ— æ³•åŠ è½½HEICåºåˆ— [\(basePattern)]ã€‚è·³è¿‡ç‰‡æ®µ [\(clipToPlay.fileName)]ã€‚")
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            let isRevealing = (clipToPlay.type == .TM_Reveal)
            let contentClip: SnoopyClip? =
            isRevealing ? currentClipsQueue[safe: currentClipIndex + 1] : nil
            
            startMaskTransitionWithHEIC(
                basePattern: basePattern, tmClip: clipToPlay, contentClip: contentClip, isRevealing: isRevealing)
            return
        }
        
        guard
            let url = Bundle(for: type(of: self)).url(
                forResource: clipToPlay.fileName, withExtension: nil)
        else {
            print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°è§†é¢‘æ–‡ä»¶ \(clipToPlay.fileName)")
            currentClipIndex += 1
            playNextClipInQueue()
            return
        }
        print("â–¶ï¸ æ’­æ”¾ç‰‡æ®µ: \(clipToPlay.fileName)")
        
        let newItem = AVPlayerItem(url: url)
        
        // æ ¹æ®å†…å®¹ç±»å‹é€‰æ‹©é€‚å½“çš„æ’­æ”¾å™¨
        if clipToPlay.type == .AS || clipToPlay.type == .SS_Intro || clipToPlay.type == .SS_Loop || clipToPlay.type == .SS_Outro {
            // AS/SSå†…å®¹ä½¿ç”¨ç‹¬ç«‹æ’­æ”¾å™¨åœ¨é¡¶å±‚æ’­æ”¾
            self.asPlayerItem = newItem
            
            // è®¾ç½®AS/SSè§†é¢‘èŠ‚ç‚¹å¯è§æ€§
            if let asVideoNode = self.asVideoNode {
                asVideoNode.isHidden = false
            }
            
            // ä½¿ç”¨ç‹¬ç«‹çš„ASæ’­æ”¾å™¨
            asPlayer?.replaceCurrentItem(with: newItem)
            asPlayer?.play()
            
            print("ğŸ“Š AS/SSå†…å®¹ä½¿ç”¨ç‹¬ç«‹æ’­æ”¾å™¨åœ¨é¡¶å±‚æ’­æ”¾")
            
            // ç›‘å¬AS/SSæ’­æ”¾å®Œæˆäº‹ä»¶
            NotificationCenter.default.addObserver(
                self,
                selector: #selector(asPlaybackEnded(_:)),
                name: .AVPlayerItemDidPlayToEndTime,
                object: newItem
            )
        } else {
            // BPã€APã€CMã€STã€RPHç­‰å†…å®¹ä½¿ç”¨ä¸»æ’­æ”¾å™¨
            self.playerItem = newItem
            
            // ç¡®ä¿AS/SSè§†é¢‘èŠ‚ç‚¹éšè—
            if let asVideoNode = self.asVideoNode {
                asVideoNode.isHidden = true
            }
            
            queuePlayer?.removeAllItems()
            queuePlayer?.insert(newItem, after: nil)
            queuePlayer?.play()
            
            print("ğŸ“Š å¸¸è§„å†…å®¹ä½¿ç”¨ä¸»æ’­æ”¾å™¨åœ¨Layer 3æ’­æ”¾")
        }
        
        if clipToPlay.type == .BP_Node || clipToPlay.type == .AP_Loop {
            let initialRepeatCount = max(1, clipToPlay.repeatCount)
            self.currentRepeatCount = max(0, initialRepeatCount - 1)
            print(
                "ğŸ” å¾ªç¯ç‰‡æ®µæ£€æµ‹åˆ°: \(clipToPlay.fileName)ã€‚å‰©ä½™é‡å¤æ¬¡æ•°: \(self.currentRepeatCount)"
            )
        } else if clipToPlay.type == .SS_Loop {
            self.currentRepeatCount = 0  // SS_Loop only plays once
            print(
                "ğŸ” å¾ªç¯ç‰‡æ®µæ£€æµ‹åˆ°: \(clipToPlay.fileName)ã€‚SS_Loop è®¾ç½®ä¸ºæ’­æ”¾ä¸€æ¬¡ã€‚"
            )
        } else {
            self.currentRepeatCount = 0
        }
        
        // VI/WE overlay logic for BP and AP loops
        if clipToPlay.type == .BP_Node || clipToPlay.type == .AP_Loop {
            let overlayChance = 0.2
            if Double.random(in: 0...1) < overlayChance {
                tryPlayVIWEOverlay()
            }
        }
    }
    
    private func updateStateForStartingClip(_ clip: SnoopyClip) {
        switch clip.type {
        case .AS:
            currentStateType = .playingAS
        case .TM_Hide:
            currentStateType = .transitioningToHalftoneHide
        case .ST_Hide:
            currentStateType = .playingSTHide
        case .RPH:
            currentStateType = .playingRPH
        case .BP_Node:
            currentStateType = .playingBP
            if let rphNode = clip.from {
                self.currentNode = rphNode
                print("ğŸ“ å½“å‰èŠ‚ç‚¹è®¾ç½®ä¸º: \(self.currentNode ?? "nil") æ¥è‡ª RPH")
            }
        case .AP_Intro:
            currentStateType = .playingAPIntro
        case .AP_Loop:
            currentStateType = .playingAPLoop
        case .AP_Outro:
            currentStateType = .playingAPOutro
        case .CM:
            currentStateType = .playingCM
        case .ST_Reveal:
            currentStateType = .transitioningToASReveal
        case .TM_Reveal:
            currentStateType = .playingTMReveal
        case .SS_Intro:
            currentStateType = .playingSSIntro
        default:
            print("âš ï¸ æœªæ˜ç¡®å¤„ç†çš„ç‰‡æ®µç±»å‹: \(clip.type)")
        }
        print("ğŸ“Š å½“å‰çŠ¶æ€æ›´æ–°ä¸º: \(currentStateType)")
    }
    
    @objc private func playerItemDidReachEnd(_ notification: Notification) {
        guard !isMasking else { return }
        
        guard let finishedItem = notification.object as? AVPlayerItem else {
            print("âš ï¸ é€šçŸ¥æ¥æ”¶åˆ°çš„å¯¹è±¡ä¸æ˜¯ AVPlayerItemã€‚å¿½ç•¥ã€‚")
            return
        }
        
        if finishedItem == self.overlayPlayerItem {
            handleOverlayItemFinish(finishedItem: finishedItem)
            return
        }
        
        // Check if this is from the AS player
        if finishedItem == self.asPlayerItem {
            print("âœ… AS/SSæ’­æ”¾å™¨å†…å®¹æ’­æ”¾å®Œæˆï¼Œç”±asPlaybackEndedå¤„ç†")
            // AS/SS playback completion is handled by asPlaybackEnded
            return
        }
        
        guard finishedItem == self.playerItem else {
            print("âš ï¸ é€šçŸ¥æ¥æ”¶åˆ°æ„å¤–çš„æ’­æ”¾å™¨é¡¹ç›®ã€‚å¿½ç•¥ã€‚")
            return
        }
        print("âœ… ä¸»æ’­æ”¾å™¨å†…å®¹æ’­æ”¾å®Œæˆã€‚")
        
        if currentRepeatCount > 0 {
            print("ğŸ” å¾ªç¯ç‰‡æ®µã€‚å‰©ä½™é‡å¤æ¬¡æ•°: \(currentRepeatCount - 1)")
            if let url = (finishedItem.asset as? AVURLAsset)?.url {
                let newItem = AVPlayerItem(url: url)
                self.playerItem = newItem
                
                queuePlayer?.removeAllItems()
                queuePlayer?.insert(newItem, after: nil)
                currentRepeatCount -= 1
                queuePlayer?.play()
                return
            }
        }
        
        guard currentClipIndex < currentClipsQueue.count else {
            print("âŒ é”™è¯¯ï¼šplayerItemDidReachEnd è°ƒç”¨æ—¶ç´¢å¼•è¶…å‡ºèŒƒå›´ã€‚")
            return
        }
        let finishedClip = currentClipsQueue[currentClipIndex]
        
        guard finishedClip.type != .TM_Hide && finishedClip.type != .TM_Reveal else {
            print("âŒ é”™è¯¯ï¼šä¸»æ’­æ”¾å™¨æ„å¤–å®Œæˆ TM ç‰‡æ®µã€‚")
            currentClipIndex += 1
            playNextClipInQueue()
            return
        }
        print("âœ… å®Œæˆä¸»ç‰‡æ®µ: \(finishedClip.fileName)")
        
        
        // BP_To_RPHæ’­æ”¾å®Œæ¯•ï¼Œé¢„åŠ è½½TM_Revealå’ŒASä»¥ä¾¿åœ¨ST_Revealæ’­æ”¾å®Œæˆåç«‹å³ä½¿ç”¨
        if finishedClip.type == .BP_To && finishedClip.to?.starts(with: "RPH") ?? false {
            print("ğŸ¬ BP_To_RPH å®Œæˆã€‚é¢„åŠ è½½TM_Revealå’ŒASã€‚")
            
            // æ£€æŸ¥ä¸‹ä¸€ä¸ªæ˜¯å¦æ˜¯ST_Reveal
            if currentClipIndex + 1 < currentClipsQueue.count
                && currentClipsQueue[currentClipIndex + 1].type == .ST_Reveal
            {
                // TM_Reveal preloading removed - now handled by HEIC sequence player
                print("ğŸ”„ Next clip is ST_Reveal - TM transitions now handled by HEIC sequence player")
            }
        }
        
        // ST_Revealæ’­æ”¾å®Œæ¯•ï¼Œå¼€å§‹TM_Revealå’ŒASçš„æ’­æ”¾æµç¨‹
        if finishedClip.type == .ST_Reveal {
            print("ğŸ¬ ST_Reveal å®Œæˆã€‚ç»§ç»­åºåˆ—ã€‚")
            
            // å¦‚æœä¸‹ä¸€ä¸ªæ˜¯TM_Revealï¼Œä½¿ç”¨TM_Revealè¿‡æ¸¡
            if currentClipIndex + 1 < currentClipsQueue.count
                && currentClipsQueue[currentClipIndex + 1].type == .TM_Reveal
            {
                // ç¬¬ä¸€æ¬¡è°ƒç”¨playerItemDidReachEndæ—¶ï¼Œæˆ‘ä»¬å·²ç»é¢„åŠ è½½TM_Revealå’ŒAS
                // å¢åŠ ç´¢å¼•å¹¶æ’­æ”¾ä¸‹ä¸€ä¸ªç‰‡æ®µï¼Œè¿™å°†è§¦å‘TM_Revealçš„å¼€å§‹
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
        }
        
        // æ ¹æ®éœ€æ±‚æ–‡æ¡£ï¼šåªæœ‰åˆæ¬¡ASæ’­æ”¾å®Œæˆåæ‰åŠ è½½èƒŒæ™¯
        // åç»­ä»BPè·³è½¬åˆ°ASçš„ä¸éœ€è¦é‡æ–°åŠ è½½èƒŒæ™¯ï¼Œå› ä¸ºèƒŒæ™¯åœ¨é¦–æ¬¡ASåå·²ç»åŠ è½½äº†
        if finishedClip.type == .AS && isFirstASPlayback {
            print("ğŸ¬ åˆæ¬¡ASæ’­æ”¾å®Œæˆï¼Œç°åœ¨åŠ è½½èƒŒæ™¯")
            updateBackgrounds()
            isFirstASPlayback = false  // æ ‡è®°åˆæ¬¡ASæ’­æ”¾å·²å®Œæˆ
        } else if finishedClip.type == .SS_Outro {
            updateBackgrounds()
        }
        
        // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœASæ˜¯é€šè¿‡TM_Revealè¿‡æ¸¡æ˜¾ç¤ºçš„ï¼Œä¸è°ƒç”¨generateNextSequence
        // å› ä¸ºåç»­åºåˆ—ä¼šç”±HEICå®Œæˆå›è°ƒå¤„ç†
        if finishedClip.type == .AS && currentStateType == .playingTMReveal {
            print("ğŸ” ASé€šè¿‡TM_Revealè¿‡æ¸¡æ˜¾ç¤ºï¼Œè·³è¿‡generateNextSequenceï¼Œç­‰å¾…HEICå®Œæˆå›è°ƒå¤„ç†")
            currentClipIndex += 1
            // ä¸è°ƒç”¨playNextClipInQueueï¼Œå› ä¸ºTM_Hideä¼šç”±HEICç³»ç»Ÿå¤„ç†
            return
        }
        
        generateNextSequence(basedOn: finishedClip)
        
        currentClipIndex += 1
        playNextClipInQueue()
    }
    
    @objc private func asPlaybackEnded(_ notification: Notification) {
        print("âœ… ASè§†é¢‘æ’­æ”¾å®Œæ¯•")
        
        // ç§»é™¤è¿™ä¸ªç‰¹å®šçš„é€šçŸ¥è§‚å¯Ÿè€…
        if let item = notification.object as? AVPlayerItem {
            NotificationCenter.default.removeObserver(
                self, name: .AVPlayerItemDidPlayToEndTime, object: item)
        }
        
        // æ£€æŸ¥å½“å‰çŠ¶æ€æ¥å†³å®šå¦‚ä½•å¤„ç†ASå®Œæˆ
        if currentStateType == .playingTMReveal {
            // ASæ˜¯é€šè¿‡TM_Revealè¿‡æ¸¡æ˜¾ç¤ºçš„ï¼Œåœ¨è¿™é‡Œå¤„ç†TM_Hide
            print("ğŸ” ASæ˜¯é€šè¿‡TM_Revealæ˜¾ç¤ºçš„ï¼Œåœ¨asPlaybackEndedä¸­å¯åŠ¨TM_Hide")
            handleASCompletionWithTMHide()
        } else if currentStateType == .playingAS && isFirstASPlayback {
            // åˆå§‹ASæ’­æ”¾å®Œæˆï¼Œéœ€è¦åŠ è½½èƒŒæ™¯å¹¶æ’­æ”¾TM_Hide
            print("ğŸ” åˆå§‹ASæ’­æ”¾å®Œæˆï¼ŒåŠ è½½èƒŒæ™¯å¹¶å¯åŠ¨TM_Hide")
            
            // æ ¹æ®éœ€æ±‚æ–‡æ¡£ï¼šåˆæ¬¡ASæ’­æ”¾å®Œæˆåæ‰åŠ è½½èƒŒæ™¯
            updateBackgrounds()
            isFirstASPlayback = false  // æ ‡è®°åˆæ¬¡ASæ’­æ”¾å·²å®Œæˆ
            
            // ç„¶åå¯åŠ¨TM_Hideè¿‡æ¸¡
            handleASCompletionWithTMHide()
        } else {
            print("ğŸ” ASä¸æ˜¯é€šè¿‡TM_Revealæ˜¾ç¤ºçš„ï¼Œä¸”ä¸æ˜¯åˆå§‹æ’­æ”¾ï¼ŒTM_Hideå·²ç”±playerItemDidReachEndå¤„ç†ï¼Œè·³è¿‡asPlaybackEndedçš„TM_Hideå¤„ç†")
            return
        }
    }
    
    private func handleASCompletionWithTMHide() {
        // è®¾ç½®çŠ¶æ€ä¸ºéšè—è¿‡æ¸¡
        currentStateType = .transitioningToHalftoneHide
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„lastTransitionNumberç”¨äºåŒ¹é…TM_Hide
        if let transitionNumber = self.lastTransitionNumber {
            print("ğŸ” ASæ’­æ”¾å®Œæˆï¼Œä½¿ç”¨ä¿å­˜çš„è½¬åœºç¼–å· \(transitionNumber) æ¥å¯åŠ¨åŒ¹é…çš„TM_Hide")
            
            // æ‰¾åˆ°åŒ¹é…çš„TM_Hideå¹¶ç›´æ¥å¯åŠ¨HEICæ’­æ”¾å™¨
            if let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: transitionNumber) {
                print("âœ… æ‰¾åˆ°åŒ¹é…çš„TM_Hide: \(tmHide.fileName)")
                startTMHideTransition(tmHide: tmHide)
            } else {
                print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°åŒ¹é…è½¬åœºç¼–å· \(transitionNumber) çš„TM_Hide")
                // å›é€€ï¼šä½¿ç”¨éšæœºTM_Hide
                if let randomTMHide = findRandomClip(ofType: .TM_Hide) {
                    print("ğŸ”„ å›é€€ï¼šä½¿ç”¨éšæœºTM_Hide: \(randomTMHide.fileName)")
                    startTMHideTransition(tmHide: randomTMHide)
                }
            }
        } else {
            // æ²¡æœ‰å­˜å‚¨çš„è½¬åœºç¼–å·ï¼Œä½¿ç”¨éšæœºTM_Hide
            print("ğŸ” æ²¡æœ‰å­˜å‚¨çš„è½¬åœºç¼–å·ï¼Œä½¿ç”¨éšæœºTM_Hide")
            if let randomTMHide = findRandomClip(ofType: .TM_Hide) {
                print("âœ… æ‰¾åˆ°éšæœºTM_Hide: \(randomTMHide.fileName)")
                startTMHideTransition(tmHide: randomTMHide)
            } else {
                print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°ä»»ä½•TM_Hideç‰‡æ®µ")
            }
        }
    }
    
    private func startTMHideTransition(tmHide: SnoopyClip) {
        // ç›´æ¥æ’­æ”¾TM_Hideï¼Œè€Œä¸æ˜¯é€šè¿‡é˜Ÿåˆ—ç³»ç»Ÿ
        if self.heicSequencePlayer == nil {
            self.heicSequencePlayer = HEICSequencePlayer()
        }
        
        guard let player = self.heicSequencePlayer else {
            print("âŒ é”™è¯¯ï¼šæ— æ³•åˆ›å»ºHEICåºåˆ—æ’­æ”¾å™¨")
            return
        }
        
        let success = player.loadSequence(basePattern: tmHide.fileName)
        if success {
            print("ğŸ­ ç›´æ¥å¯åŠ¨TM_Hide HEICåºåˆ—: \(tmHide.fileName)")
            isMasking = true
            
            // è®¾ç½®é®ç½©å¹¶æ’­æ”¾
            if let scene = self.scene,
               let maskNode = self.tmMaskSpriteNode,
               let asVideoNode = self.asVideoNode,
               let cropNode = self.cropNode {
                
                // ç¡®ä¿ASè§†é¢‘èŠ‚ç‚¹åœ¨cropNodeä¸­
                if asVideoNode.parent != cropNode {
                    asVideoNode.removeFromParent()
                    asVideoNode.position = .zero
                    cropNode.addChild(asVideoNode)
                }
                
                player.startAnimation(
                    scene: scene,
                    maskNode: maskNode,
                    targetVideoNode: asVideoNode,
                    cropNode: cropNode,
                    isRevealing: false,  // TM_Hide
                    completion: { [weak self] in
                        self?.heicSequenceMaskCompleted(
                            basePattern: tmHide.fileName,
                            isRevealing: false,
                            tmClip: tmHide
                        )
                    }
                )
            } else {
                print("âŒ é”™è¯¯ï¼šç¼ºå°‘å¿…è¦çš„èŠ‚ç‚¹æ¥å¯åŠ¨TM_Hideè¿‡æ¸¡")
            }
        } else {
            print("âŒ é”™è¯¯ï¼šæ— æ³•åŠ è½½TM_Hide HEICåºåˆ—: \(tmHide.fileName)")
        }
    }
    
    // MARK: - Overlay Management
    
    @objc private func ssOutroPlaybackEnded(_ notification: Notification) {
        print("âœ… SS_Outroè§†é¢‘æ’­æ”¾å®Œæ¯•ï¼Œå»¶è¿Ÿ2ç§’åå°†å¼€å§‹æ’­æ”¾TM_Hide")
        
        // ç§»é™¤è¿™ä¸ªç‰¹å®šçš„é€šçŸ¥è§‚å¯Ÿè€…
        if let item = notification.object as? AVPlayerItem {
            NotificationCenter.default.removeObserver(
                self, name: .AVPlayerItemDidPlayToEndTime, object: item)
        }
        
        // è®¾ç½®çŠ¶æ€ä¸ºéšè—è¿‡æ¸¡
        currentStateType = .transitioningToHalftoneHide
        
        // æ¸…é™¤å½“å‰é˜Ÿåˆ—ï¼Œé˜²æ­¢TM_Hideæ’­æ”¾æ—¶è§¦å‘playerItemDidReachEnd
        // è¿™æ ·å¯ä»¥ç¡®ä¿æ‰€æœ‰è½¬åœºç”±maskPlayerItemDidReachEndæ§åˆ¶
        if currentClipsQueue.count > 0 && currentClipIndex < currentClipsQueue.count {
            print("ğŸ”„ SSç»“æŸï¼Œæ¸…é™¤å½“å‰æ’­æ”¾é˜Ÿåˆ—ï¼Œç­‰å¾…TM_Hideå®Œæˆ")
        }
        
        // å¦‚æœæœ‰å­˜å‚¨çš„åç»­ç‰‡æ®µï¼Œåº”è¯¥ä½¿ç”¨è¿™äº›ç‰‡æ®µï¼Œè€Œä¸æ˜¯é‡æ–°ç”Ÿæˆåºåˆ—
        if !nextAfterAS.isEmpty {
            print("ğŸ¬ SSå®Œæˆï¼Œä½¿ç”¨å­˜å‚¨çš„åç»­ç‰‡æ®µï¼š\(nextAfterAS.map { $0.fileName }.joined(separator: ", "))")
            
            // ç¡®è®¤nextAfterASæ˜¯å¦åŒ…å«æˆ‘ä»¬éœ€è¦çš„ç‰‡æ®µ
            let hasAllRequiredTypes =
            nextAfterAS.contains(where: { $0.type == .TM_Hide })
            && nextAfterAS.contains(where: { $0.type == .ST_Hide })
            && nextAfterAS.contains(where: { $0.type == .RPH })
            && nextAfterAS.contains(where: { $0.type == .BP_Node })
            
            if !hasAllRequiredTypes {
                print("âš ï¸ nextAfterASä¸å®Œæ•´ï¼Œç¼ºå°‘å¿…è¦ç±»å‹ã€‚é‡æ–°ç”Ÿæˆé˜Ÿåˆ—ã€‚")
                // å¦‚æœæ²¡æœ‰å¿…è¦çš„ç±»å‹ï¼Œé‡æ–°ç”Ÿæˆ
                if let finishedClip = findClipForPlayerItem(self.playerItem!) {
                    print("ğŸ“Š SSæ’­æ”¾å®Œæˆï¼Œé‡æ–°ç”Ÿæˆä¸‹ä¸€ä¸ªåºåˆ—")
                    generateNextSequence(basedOn: finishedClip)
                }
            } else {
                // å°†åç»­ç‰‡æ®µè®¾ç½®ä¸ºå½“å‰é˜Ÿåˆ—
                currentClipsQueue = nextAfterAS
                currentClipIndex = 0
                print("âœ… å·²è®¾ç½®ä¸‹ä¸€ä¸ªé˜Ÿåˆ—ä¸ºå­˜å‚¨çš„åç»­ç‰‡æ®µ")
            }
            
            // æ¸…ç©ºå­˜å‚¨ï¼Œé˜²æ­¢é‡å¤ä½¿ç”¨
            nextAfterAS = []
        } else if let finishedClip = findClipForPlayerItem(self.playerItem!) {
            // å¦‚æœæ²¡æœ‰å­˜å‚¨çš„åç»­ç‰‡æ®µï¼Œåˆ™é€šè¿‡å¸¸è§„æ–¹å¼ç”Ÿæˆä¸‹ä¸€ä¸ªåºåˆ—
            print("ğŸ“Š SSæ’­æ”¾å®Œæˆï¼Œé¢„å…ˆç”Ÿæˆä¸‹ä¸€ä¸ªåºåˆ—")
            generateNextSequence(basedOn: finishedClip)
            
            // æ‰“å°ç”Ÿæˆçš„é˜Ÿåˆ—ä¿¡æ¯ä»¥ä¾¿è°ƒè¯•
            print("ğŸ” Debug - ç”Ÿæˆçš„æ–°é˜Ÿåˆ—åŒ…å« \(currentClipsQueue.count) ä¸ªç‰‡æ®µ:")
            for (index, clip) in currentClipsQueue.enumerated() {
                print("  [\(index)]: \(clip.fileName) (\(clip.type))")
            }
            
            // ç‰¹åˆ«æ£€æŸ¥ï¼šç¡®ä¿é˜Ÿåˆ—ä»¥TM_Hideå¼€å¤´ï¼Œä¸”åŒ…å«ST_Hideã€RPHå’ŒBP_Node
            let isValidQueue =
            currentClipsQueue.count >= 4 && currentClipsQueue[0].type == .TM_Hide
            && currentClipsQueue[1].type == .ST_Hide && currentClipsQueue[2].type == .RPH
            && currentClipsQueue[3].type == .BP_Node
            
            if !isValidQueue {
                print("âš ï¸ ç”Ÿæˆçš„é˜Ÿåˆ—ä¸åŒ…å«æ­£ç¡®çš„åºåˆ—ã€‚å°è¯•ä¿®å¤é˜Ÿåˆ—ã€‚")
                
                // å°è¯•æ‰‹åŠ¨æ„å»ºæ­£ç¡®çš„é˜Ÿåˆ—
                if let tmHide = findRandomClip(
                    ofType: .TM_Hide, matchingNumber: lastTransitionNumber)
                {
                    print("âœ… æ‰¾åˆ°TM_Hide: \(tmHide.fileName)")
                    
                    if let stHide = findMatchingST(for: tmHide, type: .ST_Hide) {
                        print("âœ… æ‰¾åˆ°ST_Hide: \(stHide.fileName)")
                        
                        if let randomRPH = findRandomClip(ofType: .RPH) {
                            print("âœ… æ‰¾åˆ°RPH: \(randomRPH.fileName)")
                            
                            if let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to)
                            {
                                print("âœ… æ‰¾åˆ°BP_Node: \(targetBPNode.fileName)")
                                
                                currentClipsQueue = [tmHide, stHide, randomRPH, targetBPNode]
                                currentClipIndex = 0
                                print("âœ… ä¿®å¤é˜Ÿåˆ—æˆåŠŸ")
                            }
                        }
                    }
                }
            }
        }
        
        
        // å¼€å§‹æ’­æ”¾TM_Hideè§†é¢‘ï¼ˆç°åœ¨ä½¿ç”¨HEICåºåˆ—æ’­æ”¾å™¨ï¼‰
        print("ğŸ¬ SSæ’­æ”¾ç»“æŸï¼ŒTM_Hideå°†é€šè¿‡HEICåºåˆ—æ’­æ”¾å™¨å¤„ç†")
    }
    
    private func generateNextSequence(basedOn finishedClip: SnoopyClip) {
        print(
            "ğŸ“Š åŸºäºå®Œæˆçš„ç‰‡æ®µç”Ÿæˆä¸‹ä¸€ä¸ªåºåˆ—: \(finishedClip.fileName) (ç±»å‹: \(finishedClip.type), çŠ¶æ€: \(currentStateType))"
        )
        var nextQueue: [SnoopyClip] = []
        
        switch finishedClip.type {
        case .AS:
            print("ğŸ¬ AS å®Œæˆã€‚é˜Ÿåˆ— Halftone è¿‡æ¸¡ã€‚")
            
            let requiredNumber = self.lastTransitionNumber
            print("ğŸ” Debug: lastTransitionNumber = \(requiredNumber ?? "nil")")
            
            guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: requiredNumber)
            else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°ç¼–å·ä¸º \(requiredNumber ?? "any") çš„ TM_Hide")
                // Don't reset lastTransitionNumber here, keep it for potential retry
                break
            }
            
            // Only reset lastTransitionNumber after successful finding of TM_Hide
            self.lastTransitionNumber = nil
            print("âœ… Guard OK: Found TM_Hide: \(tmHide.fileName)")
            
            guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°åŒ¹é… TM \(tmHide.number ?? "") çš„ ST_Hide")
                break
            }
            print("âœ… Guard OK: Found ST_Hide: \(stHide.fileName)")
            
            guard let randomRPH = findRandomClip(ofType: .RPH) else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°éšæœº RPH")
                break
            }
            print("âœ… Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
            
            guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
                print(
                    "âŒ Guard Failed: æ‰¾ä¸åˆ° RPH \(randomRPH.fileName) æŒ‡å‘çš„ BP èŠ‚ç‚¹ \(randomRPH.to ?? "nil")"
                )
                break
            }
            print("âœ… Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜å‚¨äº†nextAfterASï¼Œå¦‚æœå­˜å‚¨äº†å°±ä½¿ç”¨å®ƒ
            if !nextAfterAS.isEmpty {
                print(
                    "ğŸ¬ ASå®Œæˆï¼Œä½¿ç”¨å·²å­˜å‚¨çš„åç»­ç‰‡æ®µ: \(nextAfterAS.map { $0.fileName }.joined(separator: ", "))")
                nextQueue = nextAfterAS
                nextAfterAS = []  // æ¸…ç©ºå­˜å‚¨ï¼Œé˜²æ­¢é‡å¤ä½¿ç”¨
            } else {
                // å¦‚æœæ²¡æœ‰å­˜å‚¨ï¼Œä½¿ç”¨åˆšç”Ÿæˆçš„åºåˆ—
                nextQueue = [tmHide, stHide, randomRPH, targetBPNode]
                print("ğŸ¬ ASå®Œæˆï¼Œä½¿ç”¨æ–°ç”Ÿæˆçš„åç»­ç‰‡æ®µ")
            }
            
        case .BP_Node:
            print("ğŸ¬ BP èŠ‚ç‚¹å®Œæˆå¾ªç¯ã€‚å½“å‰èŠ‚ç‚¹: \(currentNode ?? "nil"), å‘¨æœŸè®¡æ•°: \(bpCycleCount)")
            currentStateType = .decidingNextHalftoneAction
            
            if bpCycleCount == 1 {
                print("ğŸ”„ å·²å®Œæˆ \(bpCycleCount) ä¸ª BP å‘¨æœŸï¼Œéšæœºé€‰æ‹© AS, SS æˆ– Halftone åºåˆ—ã€‚")
                bpCycleCount = 0
                
                let choice = Double.random(in: 0..<1)
                let asProbability = 0.9
                let ssProbability = 0.0
                
                if choice < asProbability {
                    print("  é€‰æ‹©ç”Ÿæˆ AS åºåˆ—ã€‚")
                    // ç‰¹æ®Šå¤„ç†ï¼šBP001æœ‰æ¦‚ç‡è¿›å…¥ASåºåˆ—ï¼ˆä½¿ç”¨å›ºå®š006ç¼–å·ï¼‰
                    if currentNode == "BP001" {
                        print("ğŸ¯ BP001é€‰æ‹©è¿›å…¥ASåºåˆ—ï¼ˆä½¿ç”¨å›ºå®š006ç¼–å·ï¼‰")
                        nextQueue = generateBP001ASSequence()
                    } else {
                        nextQueue = generateASSequence(fromNode: currentNode)
                    }
                } else if choice < asProbability + ssProbability {
                    print("  é€‰æ‹©ç”Ÿæˆ SS åºåˆ—ã€‚")
                    nextQueue = generateSSSequenceNew(fromNode: currentNode)
                } else {
                    print("  é€‰æ‹©ç”Ÿæˆ Halftone è½¬æ¢åºåˆ— (ç»§ç»­)ã€‚")
                    guard let nodeName = currentNode else {
                        print("âŒ é”™è¯¯ï¼šBP_Node å®Œæˆæ—¶ currentNode ä¸º nilã€‚å›é€€ã€‚")
                        nextQueue = generateFallbackSequence()
                        break
                    }
                    let nextSequenceFileNames = SnoopyClip.generatePlaySequence(
                        currentNode: nodeName, clips: allClips)
                    nextQueue = nextSequenceFileNames.compactMap { findClip(byFileName: $0) }
                    if nextQueue.isEmpty {
                        print("âš ï¸ æœªæ‰¾åˆ°åˆé€‚çš„ AP/CM/BP_To è½¬æ¢ã€‚å›é€€ã€‚")
                        nextQueue = generateFallbackSequence()
                    }
                }
            } else {
                print("  å‘¨æœŸæ•°æœªè¾¾ 5 çš„å€æ•° (å½“å‰: \(bpCycleCount))ï¼Œé€‰æ‹©ä¸‹ä¸€ä¸ª Halftone åŠ¨ä½œã€‚")
                
                
                guard let nodeName = currentNode else {
                    print("âŒ é”™è¯¯ï¼šBP_Node å®Œæˆæ—¶ currentNode ä¸º nilã€‚å›é€€ã€‚")
                    nextQueue = generateFallbackSequence()
                    break
                }
                let nextSequenceFileNames = SnoopyClip.generatePlaySequence(
                    currentNode: nodeName, clips: allClips)
                nextQueue = nextSequenceFileNames.compactMap { findClip(byFileName: $0) }
                if nextQueue.isEmpty {
                    print("âš ï¸ æœªæ‰¾åˆ°åˆé€‚çš„ AP/CM/BP_To è½¬æ¢ã€‚å›é€€ã€‚")
                    nextQueue = generateFallbackSequence()
                }
            }
            
        case .AP_Outro, .CM, .BP_To, .RPH:
            print("ğŸ¬ \(finishedClip.type) å®Œæˆã€‚è½¬åˆ°èŠ‚ç‚¹: \(finishedClip.to ?? "nil")")
            
            if finishedClip.type == .RPH {
                // RPHå®Œæˆï¼Œæ•´ä¸ªAS/SS â†’ TM_Hide â†’ ST_Hide â†’ RPHåºåˆ—ç»“æŸï¼Œé‡ç½®è½¬åœºç¼–å·
                print("ğŸ”„ RPHå®Œæˆï¼Œé‡ç½®lastTransitionNumber")
                self.lastTransitionNumber = nil
                
                // æ£€æŸ¥RPHæ˜¯å¦åœ¨é¢„æ„å»ºçš„åºåˆ—ä¸­ï¼ˆä¸‹ä¸€ä¸ªåº”è¯¥æ˜¯BP_Nodeï¼‰
                if let nextClipInQueue = currentClipsQueue[safe: currentClipIndex + 1],
                   nextClipInQueue.type == .BP_Node
                {
                    print("ğŸ¬ RPH (part of sequence) å®Œæˆã€‚ç»§ç»­åºåˆ—åˆ° BP_Node: \(nextClipInQueue.fileName)")
                    // æ›´æ–°å½“å‰èŠ‚ç‚¹
                    self.currentNode = finishedClip.to
                    return
                } else {
                    // RPHä¸åœ¨é¢„æ„å»ºçš„åºåˆ—ä¸­ï¼Œéœ€è¦ç”Ÿæˆæ–°çš„BP_Nodeé˜Ÿåˆ—
                    self.currentNode = finishedClip.to
                    guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: self.currentNode)
                    else {
                        print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°ç›®æ ‡ BP èŠ‚ç‚¹ \(self.currentNode ?? "nil")ã€‚å›é€€ã€‚")
                        nextQueue = generateFallbackSequence()
                        break
                    }
                    print("âœ… RPH å®Œæˆï¼Œé˜Ÿåˆ—ç›®æ ‡ BP èŠ‚ç‚¹: \(targetBPNode.fileName)")
                    nextQueue = [targetBPNode]
                    bpCycleCount += 1
                    print("ğŸ”„ å¢åŠ  BP å‘¨æœŸè®¡æ•°è‡³: \(bpCycleCount)")
                }
            } else if finishedClip.type == .BP_To {
                if finishedClip.to?.starts(with: "RPH") ?? false {
                    if let nextClipInQueue = currentClipsQueue[safe: currentClipIndex + 1],
                       nextClipInQueue.type == .ST_Reveal
                    {
                        print("ğŸ¬ BP_To_RPH (part of AS sequence) å®Œæˆã€‚ç»§ç»­åºåˆ— (ST_Reveal)ã€‚")
                        
                        // æ¸…é™¤æ‰€æœ‰å­˜å‚¨çš„è·³è½¬ååºåˆ—ï¼Œé˜²æ­¢å¾ªç¯
                        if !nextAfterAS.isEmpty {
                            print("âš ï¸ BP_To_RPHåºåˆ—å¼€å§‹ï¼Œæ¸…é™¤å·²å­˜å‚¨çš„nextAfterASé˜²æ­¢å¾ªç¯")
                            nextAfterAS = []
                        }
                        return
                    } else {
                        guard let randomRPH = findRandomClip(ofType: .RPH) else {
                            print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°ä»»ä½• RPH ç‰‡æ®µæ¥å¤„ç† BP_To_RPH å®Œæˆã€‚å›é€€ã€‚")
                            nextQueue = generateFallbackSequence()
                            break
                        }
                        print("âœ… BP_To_RPH å®Œæˆï¼Œé˜Ÿåˆ—éšæœº RPH: \(randomRPH.fileName)")
                        nextQueue = [randomRPH]
                    }
                } else {
                    self.currentNode = finishedClip.to
                    guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: self.currentNode)
                    else {
                        print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°ç›®æ ‡ BP èŠ‚ç‚¹ \(self.currentNode ?? "nil")ã€‚å›é€€ã€‚")
                        nextQueue = generateFallbackSequence()
                        break
                    }
                    print("âœ… BP_To_BP å®Œæˆï¼Œé˜Ÿåˆ—ç›®æ ‡ BP èŠ‚ç‚¹: \(targetBPNode.fileName)")
                    nextQueue = [targetBPNode]
                    bpCycleCount += 1
                    print("ğŸ”„ å¢åŠ  BP å‘¨æœŸè®¡æ•°è‡³: \(bpCycleCount)")
                }
            } else {
                // å¤„ç†å…¶ä»–ç±»å‹(.AP_Outro, .CM)
                self.currentNode = finishedClip.to
                guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: self.currentNode)
                else {
                    print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°ç›®æ ‡ BP èŠ‚ç‚¹ \(self.currentNode ?? "nil")ã€‚å›é€€ã€‚")
                    nextQueue = generateFallbackSequence()
                    break
                }
                print("âœ… \(finishedClip.type) å®Œæˆï¼Œé˜Ÿåˆ—ç›®æ ‡ BP èŠ‚ç‚¹: \(targetBPNode.fileName)")
                nextQueue = [targetBPNode]
                bpCycleCount += 1
                print("ğŸ”„ å¢åŠ  BP å‘¨æœŸè®¡æ•°è‡³: \(bpCycleCount)")
            }
            
        case .ST_Hide, .ST_Reveal:
            print("ğŸ¬ \(finishedClip.type) å®Œæˆã€‚ç»§ç»­åºåˆ—ã€‚")
            return
            
        case .TM_Hide:
            print("ğŸ¬ TM_Hide å®Œæˆã€‚ç”Ÿæˆ ST_Hide â†’ RPH â†’ BP_Node åºåˆ—ã€‚")
            
            guard let transitionNumber = finishedClip.number else {
                print("âŒ Guard Failed: TM_Hide æ²¡æœ‰æœ‰æ•ˆçš„è½¬åœºç¼–å·")
                break
            }
            
            guard let stHide = findMatchingST(forNumber: transitionNumber, type: .ST_Hide) else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°åŒ¹é… TM \(transitionNumber) çš„ ST_Hide")
                break
            }
            print("âœ… Guard OK: Found ST_Hide: \(stHide.fileName)")
            
            guard let randomRPH = findRandomClip(ofType: .RPH) else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°éšæœº RPH")
                break
            }
            print("âœ… Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
            
            guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
                print(
                    "âŒ Guard Failed: æ‰¾ä¸åˆ° RPH \(randomRPH.fileName) æŒ‡å‘çš„ BP èŠ‚ç‚¹ \(randomRPH.to ?? "nil")"
                )
                break
            }
            print("âœ… Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
            
            nextQueue = [stHide, randomRPH, targetBPNode]
            print("ğŸ¬ TM_Hideå®Œæˆï¼Œä½¿ç”¨æ–°ç”Ÿæˆçš„åºåˆ—: \(nextQueue.map { $0.fileName }.joined(separator: ", "))")
            
        case .TM_Reveal:
            print("âŒ é”™è¯¯ï¼šTM ç‰‡æ®µåœ¨ä¸»æ’­æ”¾å™¨åºåˆ—ç”Ÿæˆä¸­å®Œæˆã€‚")
            break
            
        case .SS_Outro:
            print("ğŸ¬ SS å®Œæˆã€‚é˜Ÿåˆ— Halftone è¿‡æ¸¡ã€‚")
            
            let requiredNumber = self.lastTransitionNumber
            print("ğŸ” Debug: lastTransitionNumber = \(requiredNumber ?? "nil")")
            
            guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: requiredNumber)
            else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°ç¼–å·ä¸º \(requiredNumber ?? "any") çš„ TM_Hide")
                // Don't reset lastTransitionNumber here, keep it for potential retry
                break
            }
            
            // Only reset lastTransitionNumber after successful finding of TM_Hide
            self.lastTransitionNumber = nil
            print("âœ… Guard OK: Found TM_Hide: \(tmHide.fileName)")
            
            guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°åŒ¹é… TM \(tmHide.number ?? "") çš„ ST_Hide")
                break
            }
            print("âœ… Guard OK: Found ST_Hide: \(stHide.fileName)")
            
            guard let randomRPH = findRandomClip(ofType: .RPH) else {
                print("âŒ Guard Failed: æ‰¾ä¸åˆ°éšæœº RPH")
                break
            }
            print("âœ… Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
            
            guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
                print(
                    "âŒ Guard Failed: æ‰¾ä¸åˆ° RPH \(randomRPH.fileName) æŒ‡å‘çš„ BP èŠ‚ç‚¹ \(randomRPH.to ?? "nil")"
                )
                break
            }
            print("âœ… Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜å‚¨äº†nextAfterASï¼Œå¦‚æœå­˜å‚¨äº†å°±ä½¿ç”¨å®ƒ
            if !nextAfterAS.isEmpty {
                print(
                    "ğŸ¬ SSå®Œæˆï¼Œä½¿ç”¨å·²å­˜å‚¨çš„åç»­ç‰‡æ®µ: \(nextAfterAS.map { $0.fileName }.joined(separator: ", "))")
                nextQueue = nextAfterAS
                nextAfterAS = []  // æ¸…ç©ºå­˜å‚¨ï¼Œé˜²æ­¢é‡å¤ä½¿ç”¨
            } else {
                // å¦‚æœæ²¡æœ‰å­˜å‚¨ï¼Œä½¿ç”¨åˆšç”Ÿæˆçš„åºåˆ—
                nextQueue = [tmHide, stHide, randomRPH, targetBPNode]
                print("ğŸ¬ SSå®Œæˆï¼Œä½¿ç”¨æ–°ç”Ÿæˆçš„åç»­ç‰‡æ®µ")
            }
            
        case .SS_Intro, .SS_Loop, .AP_Intro, .AP_Loop:
            print("ğŸ¬ \(finishedClip.type) å®Œæˆã€‚ç»§ç»­åºåˆ—ã€‚")
            return
            
        default:
            print("âš ï¸ æœªå¤„ç†çš„ç‰‡æ®µç±»å‹å®Œæˆ: \(finishedClip.type)ã€‚ä½¿ç”¨éšæœº AS é‡æ–°å¼€å§‹ã€‚")
            nextQueue = generateFallbackSequence()
            bpCycleCount = 0
        }
        
        if !nextQueue.isEmpty {
            print("âœ… ç”Ÿæˆæ–°é˜Ÿåˆ—ï¼ŒåŒ…å« \(nextQueue.count) ä¸ªç‰‡æ®µã€‚")
            self.currentClipsQueue = nextQueue
            self.currentClipIndex = -1
        } else if finishedClip.type != .ST_Hide && finishedClip.type != .ST_Reveal
                    && finishedClip.type != .RPH && finishedClip.type != .SS_Outro
                    && finishedClip.type != .SS_Intro && finishedClip.type != .SS_Loop
                    && finishedClip.type != .AP_Intro && finishedClip.type != .AP_Loop
        {
            print(
                "âŒ æ— æ³•ä¸º \(finishedClip.fileName) ç”Ÿæˆä¸‹ä¸€ä¸ªåºåˆ—ã€‚å¤„ç†é˜Ÿåˆ—ç»“æŸã€‚"
            )
            handleEndOfQueue()
        }
    }
    
    private func handleEndOfQueue() {
        print(
            "âŒ æ„å¤–åˆ°è¾¾é˜Ÿåˆ—æœ«å°¾æˆ–åºåˆ—ç”Ÿæˆå¤±è´¥ã€‚å›é€€åˆ°éšæœº BP_Nodeã€‚"
        )
        queuePlayer?.pause()
        queuePlayer?.removeAllItems()
        let fallbackQueue = generateFallbackSequence()
        if !fallbackQueue.isEmpty {
            self.currentClipsQueue = fallbackQueue
            self.currentClipIndex = 0
            playNextClipInQueue()
        } else {
            print("âŒ ä¸¥é‡é”™è¯¯ï¼šæ— æ³•ç”Ÿæˆå›é€€é˜Ÿåˆ—ï¼åœæ­¢æ’­æ”¾ã€‚")
        }
    }
    
    // MARK: - Sequence Generation Helpers
    
    private func generateASSequence(fromNode: String? = nil) -> [SnoopyClip] {
        var sequence: [SnoopyClip] = []
        var transitionNumber: String? = nil
        
        if let nodeName = fromNode {
            let bpToRphCandidates = allClips.filter { clip in
                guard clip.type == .BP_To, clip.to?.starts(with: "RPH") ?? false else {
                    return false
                }
                let pattern = "_BP\(nodeName.suffix(3))_To_"
                return clip.fileName.contains(pattern)
            }
            
            if let bpToRph = bpToRphCandidates.randomElement() {
                print("  Prepending BP_To_RPH: \(bpToRph.fileName) to AS sequence.")
                sequence.append(bpToRph)
            } else {
                print(
                    "âš ï¸ Warning: Could not find BP_To_RPH for node \(nodeName) to prepend to AS sequence."
                )
            }
        }
        
        guard let randomTMReveal = findRandomClip(ofType: .TM_Reveal) else {
            print("âŒ Error: Could not find random TM_Reveal for AS sequence.")
            return generateFallbackSequence()
        }
        transitionNumber = randomTMReveal.number
        print(
            "  Selected TM_Reveal: \(randomTMReveal.fileName) (Number: \(transitionNumber ?? "nil"))"
        )
        
        guard let matchingSTReveal = findMatchingST(for: randomTMReveal, type: .ST_Reveal) else {
            print(
                "âŒ Error: Could not find matching ST_Reveal for TM number \(transitionNumber ?? "nil")."
            )
            return generateFallbackSequence()
        }
        print("  Selected ST_Reveal: \(matchingSTReveal.fileName)")
        
        guard let randomAS = findRandomClip(ofType: .AS) else {
            print("âŒ Error: Could not find random AS clip.")
            return generateFallbackSequence()
        }
        print("  Selected AS: \(randomAS.fileName)")
        
        // åœ¨æ­¤å­˜å‚¨è½¬åœºç¼–å·ï¼Œä»¥ä¾¿ASæ’­æ”¾å®Œæˆåå¯ä»¥æ‰¾åˆ°åŒ¹é…çš„TM_Hide
        self.lastTransitionNumber = transitionNumber
        print("ğŸ’¾ Stored lastTransitionNumber: \(self.lastTransitionNumber ?? "nil")")
        
        // æ‰¾åˆ°åŒ¹é…çš„TM_Hideï¼Œä½†ä¸åŠ å…¥åºåˆ— - è¿™å°†åœ¨ASæ’­æ”¾å®Œæˆæ—¶ä½¿ç”¨
        guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: transitionNumber)
        else {
            print("âŒ Guard Failed: æ‰¾ä¸åˆ°ç¼–å·ä¸º \(transitionNumber ?? "any") çš„ TM_Hide")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found TM_Hide: \(tmHide.fileName) - å°†åœ¨ASå®Œæˆåä½¿ç”¨")
        
        guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
            print("âŒ Guard Failed: æ‰¾ä¸åˆ°åŒ¹é… TM \(tmHide.number ?? "") çš„ ST_Hide")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found ST_Hide: \(stHide.fileName) - å°†åœ¨TM_Hideå®Œæˆåä½¿ç”¨")
        
        guard let randomRPH = findRandomClip(ofType: .RPH) else {
            print("âŒ Guard Failed: æ‰¾ä¸åˆ°éšæœº RPH")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
        
        guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
            print(
                "âŒ Guard Failed: æ‰¾ä¸åˆ° RPH \(randomRPH.fileName) æŒ‡å‘çš„ BP èŠ‚ç‚¹ \(randomRPH.to ?? "nil")")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
        
        // å…³é”®ä¿®æ”¹: åºåˆ—ä¸­åªåŒ…å«ST_Reveal, TM_Revealå’ŒAS
        // å…¶ä»–éƒ¨åˆ†(TM_Hide, ST_Hide, RPH, BP_Node)å°†åœ¨ASæ’­æ”¾å®Œæˆåå•ç‹¬å¤„ç†
        sequence += [matchingSTReveal, randomTMReveal, randomAS]
        
        // ä¸ºåç»­ä½¿ç”¨å­˜å‚¨éœ€è¦æ’­æ”¾çš„éƒ¨åˆ†
        nextAfterAS = [tmHide, stHide, randomRPH, targetBPNode]
        
        print(
            "âœ… Generated AS sequence with \(sequence.count) clips. Stored \(nextAfterAS.count) clips for after AS."
        )
        return sequence
    }
    
    private func generateBP001ASSequence() -> [SnoopyClip] {
        var sequence: [SnoopyClip] = []
        let fixedTransitionNumber: String = "006"  // å›ºå®šä½¿ç”¨006ç¼–å·
        
        print("ğŸ¯ ç”ŸæˆBP001ä¸“ç”¨ASåºåˆ—ï¼Œä½¿ç”¨å›ºå®šè½¬åœºç¼–å·: \(fixedTransitionNumber)")
        
        // æ‰¾åˆ°ç¼–å·ä¸º006çš„TM_Reveal
        guard let tmReveal006 = findRandomClip(ofType: .TM_Reveal, matchingNumber: fixedTransitionNumber) else {
            print("âŒ Error: æ‰¾ä¸åˆ°ç¼–å·ä¸º006çš„TM_Reveal")
            return generateFallbackSequence()
        }
        print("âœ… æ‰¾åˆ°TM_Reveal: \(tmReveal006.fileName)")
        
        // éšæœºé€‰æ‹©ASç‰‡æ®µ
        guard let randomAS = findRandomClip(ofType: .AS) else {
            print("âŒ Error: æ‰¾ä¸åˆ°ASç‰‡æ®µ")
            return generateFallbackSequence()
        }
        print("âœ… æ‰¾åˆ°AS: \(randomAS.fileName)")
        
        // å­˜å‚¨è½¬åœºç¼–å·ï¼Œç”¨äºASæ’­æ”¾å®Œæˆåæ‰¾åˆ°åŒ¹é…çš„TM_Hide
        self.lastTransitionNumber = fixedTransitionNumber
        print("ğŸ’¾ å­˜å‚¨è½¬åœºç¼–å·: \(self.lastTransitionNumber ?? "nil")")
        
        // æ‰¾åˆ°ç¼–å·ä¸º006çš„TM_Hide
        guard let tmHide006 = findRandomClip(ofType: .TM_Hide, matchingNumber: fixedTransitionNumber) else {
            print("âŒ Error: æ‰¾ä¸åˆ°ç¼–å·ä¸º006çš„TM_Hide")
            return generateFallbackSequence()
        }
        print("âœ… æ‰¾åˆ°TM_Hide: \(tmHide006.fileName)")
        
        // æ‰¾åˆ°åŒ¹é…çš„ST_Hide (Aæˆ–Bå˜ä½“)
        guard let stHide = findMatchingST(for: tmHide006, type: .ST_Hide) else {
            print("âŒ Error: æ‰¾ä¸åˆ°åŒ¹é…006ç¼–å·çš„ST_Hide")
            return generateFallbackSequence()
        }
        print("âœ… æ‰¾åˆ°ST_Hide: \(stHide.fileName) (å˜ä½“: \(stHide.variant ?? "default"))")
        
        // éšæœºé€‰æ‹©RPH
        guard let randomRPH = findRandomClip(ofType: .RPH) else {
            print("âŒ Error: æ‰¾ä¸åˆ°RPHç‰‡æ®µ")
            return generateFallbackSequence()
        }
        print("âœ… æ‰¾åˆ°RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
        
        // æ‰¾åˆ°ç›®æ ‡BPèŠ‚ç‚¹
        guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
            print("âŒ Error: æ‰¾ä¸åˆ°RPHæŒ‡å‘çš„BPèŠ‚ç‚¹ \(randomRPH.to ?? "nil")")
            return generateFallbackSequence()
        }
        print("âœ… æ‰¾åˆ°ç›®æ ‡BPèŠ‚ç‚¹: \(targetBPNode.fileName)")
        
        // æ„å»ºåºåˆ— TM_Reveal -> AS
        sequence = [tmReveal006, randomAS]
        
        // å­˜å‚¨åç»­ç‰‡æ®µï¼šTM_Hide -> ST_Hide -> RPH -> BP_Node
        nextAfterAS = [tmHide006, stHide, randomRPH, targetBPNode]
        
        print("ğŸ¯ BP001 ASåºåˆ—ç”Ÿæˆå®Œæˆ: \(sequence.count)ä¸ªç‰‡æ®µï¼Œåç»­\(nextAfterAS.count)ä¸ªç‰‡æ®µ")
        print("  åºåˆ—: \(sequence.map { $0.fileName }.joined(separator: " -> "))")
        print("  åç»­: \(nextAfterAS.map { $0.fileName }.joined(separator: " -> "))")
        
        return sequence
    }
    
    private func generateSSSequenceNew(fromNode: String? = nil) -> [SnoopyClip] {
        var sequence: [SnoopyClip] = []
        let transitionNumber: String? = "001"
        
        if let nodeName = fromNode {
            let bpToRphCandidates = allClips.filter { clip in
                guard clip.type == .BP_To, clip.to?.starts(with: "RPH") ?? false else {
                    return false
                }
                let pattern = "_BP\(nodeName.suffix(3))_To_"
                return clip.fileName.contains(pattern)
            }
            
            if let bpToRph = bpToRphCandidates.randomElement() {
                print("  Prepending BP_To_RPH: \(bpToRph.fileName) to SS sequence.")
                sequence.append(bpToRph)
            } else {
                print(
                    "âš ï¸ Warning: Could not find BP_To_RPH for node \(nodeName) to prepend to SS sequence."
                )
            }
        }
        
        // å…ˆæ‰¾åˆ°éœ€è¦çš„ST_Revealå¯¹åº”çš„"001"ç¼–å·
        guard let matchingSTReveal = findMatchingST(forNumber: transitionNumber, type: .ST_Reveal)
        else {
            print(
                "âŒ Error: Could not find matching ST_Reveal for TM number \(transitionNumber ?? "nil")."
            )
            return generateFallbackSequence()
        }
        print("  Selected ST_Reveal: \(matchingSTReveal.fileName)")
        
        // æ‰¾åˆ°SSåºåˆ—çš„ä¸‰éƒ¨åˆ†ï¼šIntro, Loop, Outro
        guard let ssIntro = findRandomClip(ofType: .SS_Intro) else {
            print("âŒ Error: Could not find random ssIntro.")
            return generateFallbackSequence()
        }
        print("  Selected ssIntro: \(ssIntro.fileName)")
        
        guard let ssLoop = findRandomClip(ofType: .SS_Loop) else {
            print("âŒ Error: Could not find random ssLoop.")
            return generateFallbackSequence()
        }
        print("  Selected ssLoop: \(ssLoop.fileName)")
        
        guard let ssOutro = findRandomClip(ofType: .SS_Outro) else {
            print("âŒ Error: Could not find random ssOutro.")
            return generateFallbackSequence()
        }
        print("  Selected ssOutro: \(ssOutro.fileName)")
        
        // å­˜å‚¨ç¼–å·ï¼Œç”¨äºæ‰¾åˆ°åŒ¹é…çš„TM_Hide
        self.lastTransitionNumber = transitionNumber
        print("ğŸ’¾ Stored lastTransitionNumber: \(self.lastTransitionNumber ?? "nil")")
        
        print("ğŸ¬ SS åºåˆ—ç”Ÿæˆã€‚è§„åˆ’SSå®Œæˆåçš„Halftoneè¿‡æ¸¡ã€‚")
        
        // é¢„å…ˆç”ŸæˆSSå®Œæˆåéœ€è¦æ’­æ”¾çš„ç‰‡æ®µåºåˆ—
        guard let tmHide = findRandomClip(ofType: .TM_Hide, matchingNumber: transitionNumber)
        else {
            print("âŒ Guard Failed: æ‰¾ä¸åˆ°ç¼–å·ä¸º \(transitionNumber ?? "any") çš„ TM_Hide")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found TM_Hide: \(tmHide.fileName) - å°†åœ¨SSå®Œæˆåä½¿ç”¨")
        
        guard let stHide = findMatchingST(for: tmHide, type: .ST_Hide) else {
            print("âŒ Guard Failed: æ‰¾ä¸åˆ°åŒ¹é… TM \(tmHide.number ?? "") çš„ ST_Hide")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found ST_Hide: \(stHide.fileName) - å°†åœ¨TM_Hideå®Œæˆåä½¿ç”¨")
        
        guard let randomRPH = findRandomClip(ofType: .RPH) else {
            print("âŒ Guard Failed: æ‰¾ä¸åˆ°éšæœº RPH")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found RPH: \(randomRPH.fileName) (to: \(randomRPH.to ?? "nil"))")
        
        guard let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) else {
            print(
                "âŒ Guard Failed: æ‰¾ä¸åˆ° RPH \(randomRPH.fileName) æŒ‡å‘çš„ BP èŠ‚ç‚¹ \(randomRPH.to ?? "nil")")
            return generateFallbackSequence()
        }
        print("âœ… Guard OK: Found Target BP_Node: \(targetBPNode.fileName)")
        
        // å½“å‰åºåˆ—åªåŒ…æ‹¬ST_Revealå’ŒSSä¸‰éƒ¨åˆ†
        sequence += [matchingSTReveal, ssIntro, ssLoop, ssOutro]
        
        // ä¸ºåç»­ä½¿ç”¨å­˜å‚¨éœ€è¦æ’­æ”¾çš„éƒ¨åˆ† - è¿™å°†åœ¨SS_Outroæ’­æ”¾å®Œæˆåçš„å»¶è¿Ÿç»“æŸæ—¶ä½¿ç”¨
        nextAfterAS = [tmHide, stHide, randomRPH, targetBPNode]
        
        print(
            "âœ… Generated SS sequence with \(sequence.count) clips. Stored \(nextAfterAS.count) clips for after SS_Outro."
        )
        return sequence
    }
    
    private func generateFallbackSequence() -> [SnoopyClip] {
        print("âš ï¸ ç”Ÿæˆå›é€€åºåˆ— (éšæœº BP_Node)ã€‚")
        guard let randomBPNode = findRandomClip(ofType: .BP_Node) else {
            print("âŒ ä¸¥é‡é”™è¯¯ï¼šæ— æ³•æ‰¾åˆ°ä»»ä½• BP_Node ç‰‡æ®µè¿›è¡Œå›é€€ï¼")
            return []
        }
        bpCycleCount = 0
        lastTransitionNumber = nil
        currentNode = randomBPNode.node
        print("  å›é€€åˆ°: \(randomBPNode.fileName)")
        return [randomBPNode]
    }
    
    // MARK: - Clip Finding Helpers
    
    private func findClip(byFileName fileName: String) -> SnoopyClip? {
        return allClips.first { $0.fileName == fileName }
    }
    
    private func findClip(
        ofType type: SnoopyClip.ClipType, nodeName: String? = nil, groupID: String? = nil
    ) -> SnoopyClip? {
        return allClips.first { clip in
            var match = clip.type == type
            if let targetNodeName = nodeName {
                match =
                match
                && (clip.node == targetNodeName || clip.from == targetNodeName
                    || clip.to == targetNodeName)
            }
            if let group = groupID {
                match = match && clip.groupID == group
            }
            return match
        }
    }
    
    private func findRandomClip(ofType type: SnoopyClip.ClipType, matchingNumber: String? = nil)
    -> SnoopyClip?
    {
        let candidates = allClips.filter { $0.type == type }
        
        // Add debugging for TM clips
        if type == .TM_Hide || type == .TM_Reveal {
            print("ğŸ” Debug TM clips:")
            for clip in candidates {
                print("  - \(clip.fileName) (number: \(clip.number ?? "nil"))")
            }
        }
        
        if let number = matchingNumber {
            let filteredByNumber = candidates.filter { $0.number == number }
            if !filteredByNumber.isEmpty {
                print("ğŸ” æ‰¾åˆ°åŒ¹é…ç¼–å· \(number) çš„ \(type) ç‰‡æ®µã€‚")
                return filteredByNumber.randomElement()
            } else {
                print("âš ï¸ è­¦å‘Š: æœªæ‰¾åˆ°ç¼–å·ä¸º \(number) çš„ \(type) ç‰‡æ®µï¼Œå°†éšæœºé€‰æ‹©ã€‚")
                print("ğŸ” Available candidates: \(candidates.map { "\($0.fileName)(num:\($0.number ?? "nil"))" })")
                
                // å¯¹äºTMç±»å‹ï¼Œéšæœºé€‰æ‹©æ—¶æ’é™¤006ç¼–å·
                if type == .TM_Hide || type == .TM_Reveal {
                    let filteredCandidates = candidates.filter { $0.number != "006" }
                    if !filteredCandidates.isEmpty {
                        print("ğŸ” æ’é™¤006ç¼–å·åï¼Œä» \(filteredCandidates.count) ä¸ªå€™é€‰ä¸­éšæœºé€‰æ‹©")
                        return filteredCandidates.randomElement()
                    } else {
                        print("âš ï¸ æ’é™¤006åæ²¡æœ‰å¯ç”¨çš„TMç‰‡æ®µï¼Œä½¿ç”¨åŸå§‹å€™é€‰")
                        return candidates.randomElement()
                    }
                } else {
                    return candidates.randomElement()
                }
            }
        } else {
            // å¯¹äºTMç±»å‹ï¼Œéšæœºé€‰æ‹©æ—¶æ’é™¤006ç¼–å·
            if type == .TM_Hide || type == .TM_Reveal {
                let filteredCandidates = candidates.filter { $0.number != "006" }
                if !filteredCandidates.isEmpty {
                    print("ğŸ” æ’é™¤006ç¼–å·åï¼Œä» \(filteredCandidates.count) ä¸ªTMå€™é€‰ä¸­éšæœºé€‰æ‹©")
                    return filteredCandidates.randomElement()
                } else {
                    print("âš ï¸ æ’é™¤006åæ²¡æœ‰å¯ç”¨çš„TMç‰‡æ®µï¼Œä½¿ç”¨åŸå§‹å€™é€‰")
                    return candidates.randomElement()
                }
            } else {
                return candidates.randomElement()
            }
        }
    }
    
    private func findMatchingST(
        for tmClip: SnoopyClip? = nil, forNumber number: String? = nil, type: SnoopyClip.ClipType
    ) -> SnoopyClip? {
        guard type == .ST_Hide || type == .ST_Reveal else { return nil }
        let targetNumber = tmClip?.number ?? number
        guard let num = targetNumber else { return nil }
        
        let matchingSTs = allClips.filter { $0.type == type && $0.number == num }
        
        if matchingSTs.isEmpty {
            print("âš ï¸ è­¦å‘Šï¼šæœªæ‰¾åˆ°åŒ¹é…çš„ \(type) ç‰‡æ®µï¼Œç¼–å·ä¸º \(num)")
            return nil
        }
        
        let variants = matchingSTs.filter { $0.variant != nil }
        if !variants.isEmpty {
            return variants.randomElement()
        } else {
            return matchingSTs.first
        }
    }
    
    private func findClipForPlayerItem(_ item: AVPlayerItem) -> SnoopyClip? {
        guard let url = (item.asset as? AVURLAsset)?.url else { return nil }
        return allClips.first { clip in
            if let clipUrl = Bundle(for: type(of: self)).url(
                forResource: clip.fileName, withExtension: nil)
            {
                return clipUrl == url
            }
            return false
        }
    
    // MARK: - Background Update Functions
    
    private func updateBackgrounds() {
            print("ğŸ”„ æ›´æ–°èƒŒæ™¯...")
            
            // æ£€æŸ¥å¹¶ç¡®ä¿åŠè‰²è°ƒå±‚å¯è§
            if let halftoneNode = self.halftoneNode {
                halftoneNode.alpha = 0.3  // è®¾ç½®é€‚å½“çš„é€æ˜åº¦
            }
            
            updateBackgroundColor()
            updateBackgroundImage()
        }
        
        private func updateBackgroundColor() {
            guard let bgNode = self.backgroundColorNode else { return }
            let randomColor = colors.randomElement() ?? .black
            bgNode.color = randomColor
            bgNode.alpha = 1  // æ˜¾ç¤ºèƒŒæ™¯é¢œè‰²
            print("ğŸ¨ èƒŒæ™¯é¢œè‰²æ›´æ–°ä¸º: \(randomColor)")
        }
        
        private func updateBackgroundImage() {
            guard let imageNode = self.backgroundImageNode, !backgroundImages.isEmpty else { return }
            
            let randomImageName = backgroundImages.randomElement()!
            guard
                let imagePath = Bundle(for: type(of: self)).path(
                    forResource: randomImageName, ofType: nil),
                let image = NSImage(contentsOfFile: imagePath)
            else {
                print("âŒ æ— æ³•åŠ è½½èƒŒæ™¯å›¾ç‰‡: \(randomImageName)")
                return
            }
            
            let texture = SKTexture(image: image)
            imageNode.texture = texture
            
            guard let scene = self.scene else { return }
            
            let imageAspect = image.size.height / scene.size.height
            guard imageAspect > 0 else {
                print("âŒ é”™è¯¯: IS å›¾ç‰‡é«˜åº¦æˆ–åœºæ™¯é«˜åº¦ä¸ºé›¶ï¼Œæ— æ³•è®¡ç®— imageAspectã€‚")
                return
            }
            imageNode.size = CGSize(
                width: image.size.width / imageAspect * scale,
                height: scene.size.height * scale)
            imageNode.position = CGPoint(
                x: scene.size.width / 2,
                y: scene.size.height / 2 - scene.size.height * offside)
            imageNode.alpha = 1  // æ˜¾ç¤ºèƒŒæ™¯å›¾ç‰‡
            
            print("ğŸ–¼ï¸ èƒŒæ™¯å›¾ç‰‡æ›´æ–°ä¸º: \(randomImageName)")
        }
        
        // MARK: - Overlay (VI/WE) Functions
        
        private func tryPlayVIWEOverlay() {
            guard overlayPlayerItem == nil else {
                print("ğŸš« å åŠ å±‚å·²åœ¨æ’­æ”¾ï¼Œè·³è¿‡æ–°çš„è§¦å‘ã€‚")
                return
            }
            
            let viClips = allClips.filter { $0.type == .VI_Single || $0.type == .VI_Intro }
            let weClips = allClips.filter { $0.type == .WE_Single || $0.type == .WE_Intro }
            let candidates = viClips + weClips
            
            guard let clipToPlay = candidates.randomElement() else {
                print("ğŸ¤· æ²¡æœ‰å¯ç”¨çš„ VI/WE ç‰‡æ®µå¯ä¾›æ’­æ”¾ã€‚")
                return
            }
            
            print("âœ¨ è§¦å‘å åŠ æ•ˆæœ: \(clipToPlay.fileName)")
            playOverlayClip(clipToPlay)
        }
        
        private func playOverlayClip(_ clip: SnoopyClip) {
            guard
                let url = Bundle(for: type(of: self)).url(
                    forResource: clip.fileName, withExtension: nil)
            else {
                print("âŒ é”™è¯¯ï¼šæ‰¾ä¸åˆ°å åŠ ç‰‡æ®µæ–‡ä»¶ \(clip.fileName)")
                cleanupOverlay()
                return
            }
            
            let newItem = AVPlayerItem(url: url)
            self.overlayPlayerItem = newItem
            
            // ä¸å†éœ€è¦è®¾ç½®overlayRepeatCountï¼ŒLoopçš„ç»§ç»­ç”±ä¸»åºåˆ—çŠ¶æ€å†³å®š
            self.overlayRepeatCount = 0
            print("ğŸ“½ï¸ æ’­æ”¾å åŠ ç‰‡æ®µ: \(clip.fileName)ï¼ŒLoopæ§åˆ¶ç”±ä¸»åºåˆ—çŠ¶æ€å†³å®š")
            
            overlayPlayer?.removeAllItems()
            overlayPlayer?.insert(newItem, after: nil)
            overlayNode?.isHidden = false
            overlayPlayer?.play()
            print("â–¶ï¸ æ’­æ”¾å åŠ ç‰‡æ®µ: \(clip.fileName)")
        }
        
        private func cleanupOverlay() {
            print("ğŸ§¹ æ¸…ç†å åŠ å±‚ã€‚")
            overlayPlayer?.pause()
            overlayPlayer?.removeAllItems()
            overlayPlayerItem = nil
            overlayNode?.isHidden = true
            overlayRepeatCount = 0
        }
        
        private func isCurrentlyInBPCycle() -> Bool {
            // æ£€æŸ¥ä¸»åºåˆ—æ˜¯å¦ä»åœ¨BPå¾ªç¯çŠ¶æ€ä¸­
            let isBPLooping = (currentStateType == .playingBP || currentStateType == .playingAPLoop)
            
            // é¢å¤–æ£€æŸ¥ï¼šå¦‚æœå½“å‰é˜Ÿåˆ—ä¸­åŒ…å«æ­£åœ¨å¾ªç¯çš„BP_Nodeæˆ–AP_Loop
            let hasLoopingClip = currentClipIndex < currentClipsQueue.count &&
            (currentClipsQueue[currentClipIndex].type == .BP_Node ||
             currentClipsQueue[currentClipIndex].type == .AP_Loop) &&
            currentRepeatCount > 0
            
            let result = isBPLooping || hasLoopingClip
            print("ğŸ” isCurrentlyInBPCycle: \(result) (çŠ¶æ€: \(currentStateType), é‡å¤æ¬¡æ•°: \(currentRepeatCount))")
            return result
        }
        
        private func handleOverlayItemFinish(finishedItem: AVPlayerItem) {
            print("âœ… å åŠ ç‰‡æ®µæ’­æ”¾å®Œæˆã€‚")
            
            var lastPlayedClip: SnoopyClip? = nil
            if let finishedUrl = (finishedItem.asset as? AVURLAsset)?.url {
                lastPlayedClip = allClips.first(where: { clip in
                    if let clipUrl = Bundle(for: type(of: self)).url(
                        forResource: clip.fileName, withExtension: nil)
                    {
                        return clipUrl == finishedUrl
                    }
                    return false
                })
            }
            
            guard let finishedClip = lastPlayedClip else {
                print("âŒ æ— æ³•æ‰¾åˆ°å®Œæˆçš„å åŠ é¡¹ç›®çš„ SnoopyClipã€‚æ¸…ç†ã€‚")
                cleanupOverlay()
                return
            }
            
            print("ğŸ” å®Œæˆçš„overlayç‰‡æ®µ: \(finishedClip.fileName) (ç±»å‹: \(finishedClip.type), groupID: \(finishedClip.groupID ?? "nil"))")
            print("ğŸ” ä¸»åºåˆ—çŠ¶æ€: \(currentStateType)")
            
            var nextOverlayClip: SnoopyClip? = nil
            let groupID = finishedClip.groupID
            
            if finishedClip.type == SnoopyClip.ClipType.VI_Intro
                || finishedClip.type == SnoopyClip.ClipType.WE_Intro
            {
                let loopType: SnoopyClip.ClipType =
                (finishedClip.type == .VI_Intro) ? .VI_Loop : .WE_Loop
                nextOverlayClip = findClip(ofType: loopType, groupID: groupID)
                if let nextClip = nextOverlayClip {
                    print("âœ… å åŠ  Intro å®Œæˆï¼Œé˜Ÿåˆ— Loop: \(nextClip.fileName)")
                } else {
                    print(
                        "âŒ å åŠ  Intro å®Œæˆï¼Œä½†æœªæ‰¾åˆ°ç»„ \(groupID ?? "nil") çš„ Loopã€‚æ¸…ç†ã€‚"
                    )
                }
            } else if finishedClip.type == SnoopyClip.ClipType.VI_Loop
                        || finishedClip.type == SnoopyClip.ClipType.WE_Loop
            {
                // æ£€æŸ¥ä¸»åºåˆ—æ˜¯å¦ä»åœ¨BPå¾ªç¯ä¸­ï¼Œè€Œä¸æ˜¯ä½¿ç”¨overlayRepeatCount
                if isCurrentlyInBPCycle() {
                    // ä¸»åºåˆ—ä»åœ¨BPå¾ªç¯ä¸­ï¼Œç»§ç»­æ’­æ”¾Loop
                    nextOverlayClip = finishedClip
                    print("ğŸ” å åŠ  Loop å®Œæˆï¼Œä¸»åºåˆ—ä»åœ¨BPå¾ªç¯ä¸­ï¼Œç»§ç»­æ’­æ”¾Loop")
                } else {
                    // ä¸»åºåˆ—å·²é€€å‡ºBPå¾ªç¯ï¼Œå¼ºåˆ¶è¿›å…¥Outro
                    let outroType: SnoopyClip.ClipType =
                    (finishedClip.type == .VI_Loop) ? .VI_Outro : .WE_Outro
                    nextOverlayClip = findClip(ofType: outroType, groupID: groupID)
                    print(
                        "âœ… å åŠ  Loop å®Œæˆï¼Œä¸»åºåˆ—å·²é€€å‡ºBPå¾ªç¯ï¼Œå¼ºåˆ¶è¿›å…¥Outro: \(nextOverlayClip?.fileName ?? "æœªæ‰¾åˆ°")"
                    )
                }
            }
            
            if let nextClip = nextOverlayClip {
                playOverlayClip(nextClip)
            } else {
                print(
                    "âœ… å åŠ åºåˆ—å®Œæˆæˆ–æœªæ‰¾åˆ°ç»„ \(groupID ?? "nil") çš„ä¸‹ä¸€ä¸ªç‰‡æ®µã€‚æ¸…ç†ã€‚"
                )
                cleanupOverlay()
            }
        }
        
        private func interruptOverlayLoopAndPlayOutro(groupID: String) {
            print("ğŸ’¥ è¯·æ±‚ä¸­æ–­overlay Loopï¼ŒgroupID: \(groupID)")
            
            let outroType: SnoopyClip.ClipType?
            if findClip(ofType: .VI_Loop, groupID: groupID) != nil {
                outroType = .VI_Outro
            } else if findClip(ofType: .WE_Loop, groupID: groupID) != nil {
                outroType = .WE_Outro
            } else {
                outroType = nil
            }
            
            guard let type = outroType, let outroClip = findClip(ofType: type, groupID: groupID) else {
                print("âš ï¸ æ— æ³•æ‰¾åˆ°ç»„ \(groupID) çš„ Outro æ¥æ‰“æ–­ Loopã€‚")
                cleanupOverlay()
                return
            }
            
            print("ğŸ’¥ æ‰“æ–­å åŠ  Loopï¼Œæ’­æ”¾ Outro: \(outroClip.fileName)")
            overlayRepeatCount = 0  // é‡ç½®é‡å¤è®¡æ•°ï¼Œå¼ºåˆ¶ç»“æŸLoop
            playOverlayClip(outroClip)
        }
        
        // MARK: - Masking Functions
        
        private func startMaskTransitionWithHEIC(basePattern: String, tmClip: SnoopyClip, contentClip: SnoopyClip?, isRevealing: Bool) {
            print("ğŸ­ å¼€å§‹HEICé®ç½©è¿‡æ¸¡: \(basePattern), TMç‰‡æ®µ: \(tmClip.fileName), æ˜¾ç¤º: \(isRevealing)")
            guard let scene = self.scene else {
                print("âŒ é”™è¯¯ï¼šHEICé®ç½©è¿‡æ¸¡ç¼ºå°‘åœºæ™¯ç»„ä»¶ã€‚")
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            isMasking = true
            
            // åˆ›å»ºmask sprite nodeå¦‚æœä¸å­˜åœ¨
            if self.tmMaskSpriteNode == nil {
                let maskNode = SKSpriteNode(color: .clear, size: scene.size)
                maskNode.position = .zero  // ç›¸å¯¹äºcropNodeçš„ä½ç½®
                self.tmMaskSpriteNode = maskNode
            }
            
            guard let maskNode = self.tmMaskSpriteNode,
                  let asVideoNode = self.asVideoNode,  // Use AS video node instead of main video node
                  let heicPlayer = self.heicSequencePlayer
            else {
                print("âŒ é”™è¯¯ï¼šHEICé®ç½©è¿‡æ¸¡ç¼ºå°‘è§†é¢‘èŠ‚ç‚¹ç»„ä»¶ã€‚")
                isMasking = false
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            // è®¾ç½®maskNodeå°ºå¯¸
            maskNode.size = scene.size
            maskNode.position = .zero  // ç›¸å¯¹äºcropNode
            
            // åˆ›å»ºæˆ–é‡ç”¨cropNodeæ¥åº”ç”¨é®ç½©æ•ˆæœ
            guard let cropNode = self.cropNode else {
                print("âŒ é”™è¯¯ï¼šcropNodeåº”è¯¥åœ¨åˆå§‹åŒ–æ—¶å·²åˆ›å»º")
                isMasking = false
                currentClipIndex += 1
                playNextClipInQueue()
                return
            }
            
            // cropNodeå§‹ç»ˆä¿æŒåœ¨zPosition=10ï¼Œä¸éœ€è¦è°ƒæ•´å±‚çº§
            
            // ç§»é™¤æ—§çš„å­èŠ‚ç‚¹å’Œçˆ¶èŠ‚ç‚¹å…³ç³» - AS video node is already in cropNode
            // No need to move asVideoNode since it's already positioned correctly in cropNode
            
            // å°†maskNodeè®¾ç½®ä¸ºcropNodeçš„mask
            cropNode.maskNode = maskNode
            
            if isRevealing {
                // TM_Reveal: æ˜¾ç¤ºAS/SS
                guard let contentClip = contentClip,
                      let contentUrl = Bundle(for: type(of: self)).url(
                        forResource: contentClip.fileName, withExtension: nil)
                else {
                    print("âŒ é”™è¯¯ï¼šHEICæ˜¾ç¤ºè¿‡æ¸¡ç¼ºå°‘å†…å®¹ç‰‡æ®µ (AS/SS)ã€‚")
                    isMasking = false
                    currentClipIndex += 1
                    playNextClipInQueue()
                    return
                }
                
                print("ğŸ”„ å‡†å¤‡æ˜¾ç¤ºå†…å®¹: \(contentClip.fileName)")
                
                // ä¸ºAS/SSå†…å®¹å‡†å¤‡ç‹¬ç«‹æ’­æ”¾å™¨
                let newItem = AVPlayerItem(url: contentUrl)
                self.asPlayerItem = newItem
                asPlayer?.replaceCurrentItem(with: newItem)
                asPlayer?.pause()  // æš‚åœç›´åˆ°é®ç½©å®Œæˆ
                
                // ç¡®ä¿ASè§†é¢‘èŠ‚ç‚¹å¯è§
                asVideoNode.isHidden = false
                
                if contentClip.type == .AS {
                    // æ›´æ–°å½“å‰çŠ¶æ€
                    currentStateType = .playingTMReveal
                    // ä½¿ç”¨TM_Revealçš„ç¼–å·è€Œä¸æ˜¯ASçš„ç¼–å·ï¼Œå› ä¸ºASé€šå¸¸æ²¡æœ‰ç¼–å·
                    self.lastTransitionNumber = tmClip.number  
                    print("ğŸ’¾ TM_Revealè¿‡æ¸¡æœŸé—´å­˜å‚¨è½¬åœºç¼–å·: \(self.lastTransitionNumber ?? "nil")")
                } else if contentClip.type == .SS_Intro {
                    currentStateType = .playingSSIntro
                }
                
                // å¼€å§‹æ’­æ”¾HEICåºåˆ—
                heicPlayer.play(on: maskNode) { [weak self] in
                    DispatchQueue.main.async {
                        self?.heicSequenceMaskCompleted(isRevealing: true, tmClip: tmClip, basePattern: basePattern)
                    }
                }
            } else {
                // TM_Hide: éšè—å½“å‰å†…å®¹
                if self.currentStateType == .playingAS {
                    currentStateType = .transitioningToHalftoneHide
                }
                
                // æ’­æ”¾HEICåºåˆ—
                heicPlayer.play(on: maskNode) { [weak self] in
                    DispatchQueue.main.async {
                        self?.heicSequenceMaskCompleted(isRevealing: false, tmClip: tmClip, basePattern: basePattern)
                    }
                }
            }
        }
        
        private func heicSequenceMaskCompleted(isRevealing: Bool, tmClip: SnoopyClip, basePattern: String) {
            print("âœ… HEICé®ç½©åºåˆ—å®Œæˆ: \(basePattern), æ˜¾ç¤º: \(isRevealing), TMç‰‡æ®µ: \(tmClip.fileName)")
            
            if isRevealing {
                // TM_Revealå®Œæˆï¼šå¼€å§‹æ’­æ”¾AS/SSå†…å®¹
                print("â–¶ï¸ TM_Revealå®Œæˆï¼Œå¼€å§‹æ’­æ”¾AS/SSå†…å®¹")
                asPlayer?.play()  // Use AS player instead of queue player
                
                // å¦‚æœå½“å‰æ’­æ”¾çš„æ˜¯ASï¼Œæ¸…é™¤é˜Ÿåˆ—
                if currentStateType == .playingTMReveal && currentClipIndex + 1 < currentClipsQueue.count &&
                    currentClipsQueue[currentClipIndex + 1].type == .AS {
                    print("ğŸ”„ ASæ˜¾ç¤ºï¼Œæ¸…ç†é˜Ÿåˆ—")
                    currentClipIndex += 1  // ç§»åˆ°AS
                }
            } else {
                // TM_Hideå®Œæˆï¼šéšè—AS/SSå†…å®¹å¹¶ç»§ç»­åˆ°ä¸‹ä¸€ä¸ªåºåˆ—
                print("â–¶ï¸ TM_Hideå®Œæˆï¼Œéšè—AS/SSå†…å®¹å¹¶ç»§ç»­åˆ°ä¸‹ä¸€ä¸ªåºåˆ—")
                
                // éšè—ASè§†é¢‘èŠ‚ç‚¹
                if let asVideoNode = self.asVideoNode {
                    asVideoNode.isHidden = true
                }
                
                // æš‚åœASæ’­æ”¾å™¨
                asPlayer?.pause()
                
                // ä½¿ç”¨å½“å‰TM_Hideç‰‡æ®µçš„ç¼–å·æ¥ç”ŸæˆST_Hideåºåˆ—
                let transitionNumber = tmClip.number
                print("ğŸ” ä½¿ç”¨TM_Hideç¼–å·ç”Ÿæˆåºåˆ—: \(transitionNumber ?? "nil")")
                
                if !nextAfterAS.isEmpty {
                    print("ğŸ”„ ä½¿ç”¨é¢„å­˜é˜Ÿåˆ—: \(nextAfterAS.count) ç‰‡æ®µ")
                    
                    // ç¡®ä¿nextAfterASåŒ…å«é¢„æœŸçš„ST_Hide â†’ RPH â†’ BP_Nodeåºåˆ—
                    if nextAfterAS.count >= 3 && nextAfterAS[0].type == .ST_Hide {
                        print("âœ… ç¡®è®¤é˜Ÿåˆ—æ­£ç¡®ï¼šä¸‹ä¸€ä¸ªç‰‡æ®µæ˜¯ST_Hide: \(nextAfterAS[0].fileName)")
                        
                        // è®¾ç½®å½“å‰é˜Ÿåˆ—å¹¶ä»ç´¢å¼•0å¼€å§‹ï¼ˆå³ST_Hideï¼‰
                        currentClipsQueue = nextAfterAS
                        currentClipIndex = 0
                        nextAfterAS = []
                        
                    } else {
                        print("âš ï¸ nextAfterASé˜Ÿåˆ—ä¸æ­£ç¡®ï¼Œå°è¯•é‡æ–°ç”Ÿæˆæ­£ç¡®çš„åºåˆ—")
                        
                        // ä½¿ç”¨TM_Hideçš„ç¼–å·é‡æ–°ç”Ÿæˆæ­£ç¡®çš„åºåˆ—
                        if let number = transitionNumber,
                           let stHide = findMatchingST(forNumber: number, type: .ST_Hide),
                           let randomRPH = findRandomClip(ofType: .RPH),
                           let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) {
                            
                            // é‡æ–°åˆ›å»ºæ­£ç¡®çš„é˜Ÿåˆ—
                            currentClipsQueue = [stHide, randomRPH, targetBPNode]
                            currentClipIndex = 0
                            print("âœ… æˆåŠŸé‡å»ºé˜Ÿåˆ—: ST_Hide â†’ RPH â†’ BP_Node")
                        } else {
                            print("âŒ æ— æ³•ç”Ÿæˆæ­£ç¡®çš„ST_Hideåºåˆ—ï¼Œä½¿ç”¨å›é€€åºåˆ—")
                            let fallbackQueue = generateFallbackSequence()
                            if !fallbackQueue.isEmpty {
                                currentClipsQueue = fallbackQueue
                                currentClipIndex = 0
                            }
                        }
                    }
                } else {
                    print("ğŸ”„ æ²¡æœ‰é¢„å­˜é˜Ÿåˆ—ï¼ŒåŸºäºTM_Hideç¼–å·ç”ŸæˆST_Hide â†’ RPH â†’ BP_Nodeåºåˆ—")
                    
                    // ç›´æ¥ä½¿ç”¨TM_Hideçš„ç¼–å·ç”ŸæˆST_Hideåºåˆ—
                    if let number = transitionNumber,
                       let stHide = findMatchingST(forNumber: number, type: .ST_Hide),
                       let randomRPH = findRandomClip(ofType: .RPH),
                       let targetBPNode = findClip(ofType: .BP_Node, nodeName: randomRPH.to) {
                        
                        currentClipsQueue = [stHide, randomRPH, targetBPNode]
                        currentClipIndex = 0
                        print("âœ… åŸºäºTM_Hideç¼–å· \(number) ç”Ÿæˆé˜Ÿåˆ—: ST_Hide â†’ RPH â†’ BP_Node")
                    } else {
                        print("âŒ æ— æ³•åŸºäºTM_Hideç¼–å·ç”Ÿæˆåºåˆ—ï¼Œä½¿ç”¨å›é€€åºåˆ—")
                        let fallbackQueue = generateFallbackSequence()
                        if !fallbackQueue.isEmpty {
                            currentClipsQueue = fallbackQueue
                            currentClipIndex = 0
                        }
                    }
                }
            }
            
            // æ¸…ç†cropNodeé®ç½©æ•ˆæœ
            if let cropNode = self.cropNode {
                // æ¸…é™¤é®ç½©æ•ˆæœ
                cropNode.maskNode = nil
                print("ğŸ§¹ æ¸…ç†cropNodeé®ç½©æ•ˆæœ")
                
                // ASè§†é¢‘èŠ‚ç‚¹å§‹ç»ˆä¿æŒåœ¨cropNodeä¸­ï¼Œä¸éœ€è¦ç§»åŠ¨
                // cropNode will be reused for future AS/SS content with masking
            }
            
            // é‡ç½®çŠ¶æ€
            isMasking = false
            
            // ç»§ç»­é˜Ÿåˆ—å¤„ç†
            playNextClipInQueue()
        }
        
        // Old AVPlayer-based mask transition removed - replaced by startMaskTransitionWithHEIC
        
        // TM mask playback is now handled by HEIC sequence player via heicSequenceMaskCompleted callback
        
        // Helper methods for TM management are now handled by HEIC sequence player
        
        // MARK: - ScreenSaverView Overrides & Lifecycle
        
        override func startAnimation() {
            super.startAnimation()
            queuePlayer?.play()
            asPlayer?.play()  // Start AS player if it has content
            if overlayPlayerItem != nil {
                overlayPlayer?.play()
            }
        }
        
        override func stopAnimation() {
            super.stopAnimation()
            queuePlayer?.pause()
            asPlayer?.pause()  // Pause AS player
            overlayPlayer?.pause()
        }
        
        override func draw(_ rect: NSRect) {
            super.draw(rect)
        }
        
        override func animateOneFrame() {
        }
        
        override var hasConfigureSheet: Bool {
            return false
        }
        
        override var configureSheet: NSWindow? {
            return nil
        }
        
        @objc static func isCompatibleWithModernScreenSaverEngine() -> Bool {
            return true
        }
        
        // MARK: - Notifications
        
        private func setNotifications() {
            DistributedNotificationCenter.default.addObserver(
                self,
                selector: #selector(willStop(_:)),
                name: Notification.Name("com.apple.screensaver.willstop"),
                object: nil
            )
            
            DistributedNotificationCenter.default.addObserver(
                self,
                selector: #selector(willStart(_:)),
                name: Notification.Name("com.apple.screensaver.willstart"),
                object: nil
            )
            
            NSWorkspace.shared.notificationCenter.addObserver(
                self,
                selector: #selector(onSleepNote(note:)),
                name: NSWorkspace.willSleepNotification,
                object: nil
            )
        }
        
        @objc private func willStop(_ notification: Notification) {
            print("å±ä¿å°†è¦åœæ­¢")
            
            if #available(macOS 14.0, *) {
                DispatchQueue.main.async {
                    exit(0)
                }
            }
            
            stopAnimation()
        }
        
        @objc private func willStart(_ notification: Notification) {
            print("å±ä¿å°†è¦å¼€å§‹")
        }
        
        @objc private func onSleepNote(note: Notification) {
            print("ç³»ç»Ÿå°†è¦ç¡çœ ")
            
            if #available(macOS 14.0, *) {
                DispatchQueue.main.async {
                    exit(0)
                }
            }
        }
        
        deinit {
            NotificationCenter.default.removeObserver(self)
            DistributedNotificationCenter.default.removeObserver(self)
            NSWorkspace.shared.notificationCenter.removeObserver(self)
            // observeMaskPlayerItem removed - no longer needed for HEIC sequence player
            
            queuePlayer?.pause()
            queuePlayer = nil
            overlayPlayer?.pause()
            overlayPlayer = nil
            // tmMaskPlayer removed - now using HEIC sequence player for TM animations
        }
    }
}

// MARK: - Array Extension

extension Array {
    subscript(safe index: Int) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
